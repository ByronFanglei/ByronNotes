# 前端面试概述题
## HTML部分
### HTML常见的块级元素与行级元素
* 行级：不能设置宽高（内容撑开），水平排列【span，a，i，b，strong，em】
* 块级：可以设置宽高，垂直排列【div，p，ul，li，h1，ol】
* display：block，inline，inline-block	即可以设置宽高，又可以水平分布
### HTML5 有哪些新特性？
* 不需要任何插件就可以实现动画，视频，图形等效果，替代flash插件
* 声明方式
>HTML4 规定了三种声明方式，分别是：严格模式Strict、过渡模式Transitional  和 框架集模式Frameset
>而HTML5因为不是SGML的子集，只需要<!DOCTYPE html>就可以了

* 语义化更好的内容标签：header，footer，article，aside，section，details，summary，dialog，nav，有助于SEO的优化
* 音频，视频：audio，video，【提醒，MP4在h5可能存在声音和视频不同步的问题，大概是4s】
* HTML5 拥有多个新的表单输入类型。这些新特性提供了更好的输入控制和验证：color，date，datetime，datetime-local，email，month，number，range，search，tel，time，url，week
* 本地存储/离线存储API：
>长期存储数据的 localStorage	比较常用
>临时存储的 sessionStorage，浏览器关闭后自动删除	不常用

* 地理API：Geolocation
* 拖拽释放API
* Web Workers
* websocket（不断开链接）很适合做网页版的聊天工具

### HTML5 引入什么新的表单属性
* form：
>autocomplete:属性规定表单是否应该启用自动完成功能  《form autocomplete="on|off"》
>novalidate:如果使用该属性，则提交表单时不进行内容的验证	novalidate="novalidate"

* input:
>autocomplete：属性规定表单是否应该启用自动完成功能，大意可以查看之前输入的内容
>autofocus：加载页面后，自动获取光标
>list：引用包含输入字段的预定义选项的 datalist 
>min 和 max：min 属性与 max 属性配合使用，可创建合法值范围，两个要一对用
>pattern ：规定用于验证输入字段的正则表达式
>placeholder：提供可描述输入字段预期值的提示信息
>required：规定必需在提交之前填写输入字段。 如果使用该属性，则字段是必填（或必选）的
>step：为输入域规定合法的数字间隔。 如果 step=“3”，则合法的数是 -3,0,3,6 等

### 与 HTML4 相比 HTML5 废弃了哪些元素
* basefont、big、center、font、s、strike、tt、u、frame、frameset、noframes

###	如何处理 HTML5 新标签的浏览器兼容问题
```javascript
<!--[if lt IE 9]>
<script type="text/javascript" src="js/html5shiv.js"></script>
<![endif]-->
```

### URI与URL的区别
* URI：统一资源标识符，标识一个资源
* URL：统一资源定位器，就是一个具体的url
* URL包含（协议，ip或域名，端口，目录，文件名）


## CSS部分
### BFC
* BFC：块级格式化上下文，它是一个独立的渲染区域，
* BFC规则：
>内部的box会在垂直方向，一个接一个的放置
>box垂直方向的距离有margin决定，属于同一个BFC的两个相邻box的margin会发生重叠
>每个元素的margin box的左边，与包含块border box的左边相接触 即使在浮动也如此
>BFC的区域不会与float box重叠
>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之也如此
>计算BFC的高度时，浮动元素也参与计算

* 创建BFC的方法：
>position：absolute或者fixed
>float：不是none
>overflow： 不为visible
>display： inline-block或者flex，table-cell，table-caption，inline-flex
>根元素：html元素

### 盒子垂直居中的方法
* 表格居中
* flex居中
* 绝对定位居中

### link与@import区别
* link是html代码
* @import是css代码，可以写在html代码中，会阻塞页面的渲染，不推荐

### css常见的选择器
* id，class， 标签【p】
* 后代选择器【div p】，子代选择器【div>p】，紧邻选择器【div+p】，匹配任何在div元素之后的同级p元素【div~p】，分组选择器【div，p】
* 伪类选择器 :hover{}，伪元素选择器::after
* 属性选择器 div[a]

### css的优先级
* !important > 内联 > id选择器 > class选择器 > 标签选择器

### 浮动问题
* 清除浮动的方式：
1、在浮动的元素下面添加一个标签，添加属性clear：both；
2、添加clearfix样式，原理与上一样，添加after为元素并设置 content: "";display: block; clear:both
3、父元素添加overflow:hidden
4、父元素 float

### 定位问题 position
* static：默认的
* absolute：绝对定位，相对于最近已定位的祖先元素，定位后空间释放
* relative：相对定位，相对于自己初始位置，定位后空间不释放
* fixed：固定定位，相对于浏览器定位，定位后空间释放
* sticky：粘性定位，相当与吸顶效果

### 盒模型
* 标准盒模型：width属性 = content宽度
* 怪异盒模型：width属性 = content + padding + border宽度
* box-sizing: content-box 标准盒模型，border-box怪异盒模型

### 外边距合并问题
* 父元素添加overflow:hidden
* 父元素浮动或定位
* 子元素浮动或定位
* 父元素添加边框

### 重绘 重排
* 重绘：一个元素的外边被改变，但是没有改变布局，的情况下发生，如改变visibility，outline，背景色等
* 重排：DOM的变化影响到了元素的几何属性，浏览器会重新计算元素的几何属性，如改变窗口的大小，文字的大小，内容的改变，浏览器窗口变化，style属性的改变等
* reflow（回流）：当浏览器某个部分发生了变化影响了布局，需要倒回去重新渲染

### display部分
* display：inline，block，inline-block，flex，table，table-cell

### 显示隐藏
* display：none，block	不占空间，没有事件
* opacity： 0， 1	占空间，有事件
* visibility： hidden， visible	占空间	没有事件


## JavaScript部分
### JavaScript 中有几种数据类型
* 基本数据类型：String、Number、Boolean 、Null、Undefined、Symbol、BigInt 
* 引用数据类型：Object、Array

### 查看数据类型
* typeof：只可以分辨出基本数据类型和引用数据类型，引用数据类型都为object

```javascript
console.log(typeof '') // string
console.log(typeof 1) // number
console.log(typeof true) // boolean
console.log(typeof Symbol()) // symbol
console.log(typeof undefined) // undefined
console.log(typeof function () {}) // function
console.log(typeof 11n) // bigint, 需要直接在浏览器中执行
console.log(typeof null) // object
console.log(typeof []) // object
console.log(typeof {}) // object
console.log(typeof new Date()) // object
console.log(typeof new RegExp()) // object
```
* instanceof：可以精准的检测引用数据类型

```javascript
console.log({} instanceof Object) // true
console.log([] instanceof Array) // true
console.log([] instanceof Object) // true
console.log('1' instanceof String) // false
console.log(new String('1') instanceof String) // true
```
* Object.prototype.toString.call()：可以精准的检测所有的数据类型

```javascript
console.log(Object.prototype.toString.call('')) // [object String]
console.log(Object.prototype.toString.call(1)) // [object Number]
console.log(Object.prototype.toString.call(true)) // [object Boolean]
console.log(Object.prototype.toString.call(Symbol())) // [object Symbol]
console.log(Object.prototype.toString.call(undefined)) // [object Undefined]
console.log(Object.prototype.toString.call(null)) // [object Null]
console.log(Object.prototype.toString.call(function () {})) // [object Function]
console.log(Object.prototype.toString.call([])) // [object Array]
console.log(Object.prototype.toString.call({})) // [object Object]
console.log(Object.prototype.toString.call(11n)) // [object BigInt], 需要直接在浏览器中执行
```

### 值类型和引用类型的区别
* 存储位置不同：值类型：栈，引用类型：堆
* 复制方式不同：值类型是深拷贝，引用类型则是浅拷贝
* 值类型无法添加属性，引用类型可以添加属性
* 值类型是比较值，引用类型是比较引用地址比较

### 类型转换
* 一般判断null，undefined使用== 其他一律使用===

### ==规则
* 对象==字符串：对象.toString()变为字符串
* null==underfined相等，但是和其他值比较就不在相等了
* NaN==NaN不相等
* 剩下的都转换为数组

### 列举强制类型转换和隐式类型转化
* 强制：parseInt，parseFloat，toString
* 隐式：if， 逻辑，==，+拼接字符串

### JavaScript 数据类型，null不存在的原因
* 不存在的原因：方法不存在，对象不存在，字符串变量不存在，接口类型对象没初始化
* 解决方法：做判断处理的时候，放在设定值的最前面

### JavaScript 什么叫全局变量?什么叫局部变量了?是如何定义出来的?
* 全局变量是在函数外部定义的变量,在JS中全局变量属于window对象,其作用域是整个源程序,全局变量全部存放在静态存储区,在程序开始执行时给全局变量分配存储区,程序运行完毕就释放。
  局部变量是相对与全局变量而言的,在特定过程或函数中可以访问的变量,作用域较小,当函数运行结束释放局部变量。

### JavaScript 书写规范/原则
>1.不要在同一行声明多个变量。
>2.请使用 === /!==来比较true/false或者数值
>3.使用对象字面量替代new Array这种形式
>4.尽量不使用全局函数。
>5.switch语句必须带有default分支
>6.函数不应该有时候有返回值，有时候没有返回值。
>7.for循环必须使用大括号
>8.if语句必须使用大括号
>9.for-in循环中的变量 应该使用let或const关键字明确限定作用域，从而避免作用域污染。

### JavaScript 说一说html代码,css代码和js代码的注释写法?
>HTML：<!--注释的内容-->
>CSS：/* 注释内容 */
>JS：//注释内容			/*注释内容*/

### JavaScript NaN是什么意思?这个值有什么特点?
>NaN 表示不是一个数,但是它本身是 number 类型。
>NaN 和 NaN 不相等

### JavaScript new操作符具体干了什么呢?
>创建一个空对象,并且 this 变量引用该对象,同时还继承了该函数的原型
>属性和方法被加入到 this 引用的对象中
>新创建的对象由 this 所引用,并且最后隐式的返回 this

### 对JSON的了解?
>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式
>它是基于JavaScript的一个子集
>数据格式简单, 易于读写, 传输占用带宽小
>JSON对象包含两个方法: 用于解析 JSON 的 parse() 方法，以及将对象/值转换为 JSON字符串的 stringify() 方法	深拷贝
>除了这两个方法, JSON这个对象本身并没有其他作用，也不能被调用或者作为构造函数调用	

### JavaScript document.write 和 innerHTML的区别?
>document.write 只能重绘整个页面
>innerHTML 可以重绘页面的一部分

### JavaScript 哪些操作会造成内存泄露?
* 什么是内存泄露：内存泄漏指任何对象在你不再拥有或需要它之后仍然存在
* 哪些操作会造成内存泄露
>setTimeout 的第一个参数使用字符串而非函数的话,会引发内存泄漏
>闭包
>控制台日志
>循环引用（在两个对象彼此引用且彼此保留时,就会产生一个循环）
>DOM插入顺序

* 如何检测
>最简单的检测内存泄漏的方式是用任务管理器检查内存使用情况。在Chrome浏览器的新选项卡中打开应用并查看内存使用量是不是越来越多

### JavaScript 什么是"use strict"?使用它的好处和坏处分别是什么?
* 严格模式
* 优点：
>消除Javascript语法的一些不合理、不严谨之处,减少一些怪异行为
>消除代码运行的一些不安全之处,保证代码运行的安全
>提高编译器效率,增加运行速度
>为未来新版本的Javascript做好铺垫，	经过测试 IE6,7,8,9 均不支持严格模式

* 缺点
>现在网站的 JS 都会进行压缩,一些文件用了严格模式,而另一些没有
>这时这些本来是严格模式的文件,被 merge 后,这个串就到了文件的中间,不仅没有指示严格模式,反而在压缩后浪费了字节

### JavaScript eval是做什么的?
>eval()函数,这个函数可以把一个字符串当作一个JavaScript表达式一样去执行它
>它的功能是把对应的字符串解析成JS代码并运行
>应该避免使用eval,不安全,耗性能（2次,一次解析成js语句,一次执行）

### 浏览器的严格模式与混杂模式
* 浏览器解析时到底使用严格模式还是混杂模式，与网页中的 DTD(Document Type Definition) 直接相关
>1、如果文档包含严格的 DOCTYPE ，那么它一般以严格模式呈现。（严格 DTD ——严格模式）
>2、包含过渡 DTD 和 URI 的 DOCTYPE ，也以严格模式呈现，但有过渡 DTD 而没有 URI （统一资源标识符，就是声明最后的地址）会导致页面以混杂模式呈现。（有 URI 的过渡 DTD ——严格模式；没有 URI 的过渡 DTD ——混杂模式）
>3、DOCTYPE 不存在或形式不正确会导致文档以混杂模式呈现。（DTD不存在或者格式不正确——混杂模式）
>4、HTML5 没有 DTD ，因此也就没有严格模式与混杂模式的区别，HTML5 有相对宽松的语法，实现时，已经尽可能大的实现了向后兼容。（ HTML5 没有严格和混杂之分）

### JavaScript 谈谈 this 对象的理解
>this 指的是调用函数的那个对象
>this 在没有运行之前不能知道代表谁;js的this 指向是不确定的；和定义没有关系，和执行有关
>执行的时候，点前面是谁，this 就是谁；自执行函数里面的this 代表的是 window
>定时器书写的时候，window可以省略掉；定时器执行的时候，里面的this 代表的也是 window
>this 是js的一个关键字，随着函数使用场合不同，this 的值会发生变化

### JavaScript 什么是window对象? 什么是document对象?
>document 是 window 的一个对象属性
>window 对象表示浏览器中打开的窗口
>如果文档包含框架（frame 或 iframe 标签），浏览器会为 HTML 文档创建一个 window 对象，并为每个框架创建一个额外的 window 对象
>所有的全局函数和对象都属于Window 对象的属性和方法
>document 对 Document 对象的只读引用

### JavaScript原型，原型链 ? 有什么特点
* 原型
>在JavaScript中,一共有两种类型的值,原始值和对象值.每个对象都有一个内部属性 prototype,我们通常称之为原型
>原型的值可以是一个对象,也可以是null
>访问一个对象的原型可以使用Object.getPrototypeOf方法,或者__proto__属性

* 原型链：原型向上查找的过程属于原型链
* 特点：
>可以向上查找，不能向下查找
>原型链的作用是用来实现继承的

### Javascript中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是?
* javaScript中hasOwnProperty函数方法是返回一个布尔值，指出一个对象是否具有指定名称的属性。object.hasOwnProperty(proName)

### 把 Script 标签 放在页面的最底部的body封闭之前 和封闭之后有什么区别？浏览器会如何解析它们？
* 从实际效果来看，是没有区别的，但是放在 html 结束标签之前应该是不规范的(通不过 HTML 验证)，放在 body 结束之前才对，

### script标签的位置会影响首屏时间么？
* 不影响但有可能截断首屏的内容，使其只显示上面一部分

### cookie，localstoracge，sessionstorage区别
* 存储大小：cookie4k，storage5M
* 有效期：cookie拥有有效期，sessionstorage会话存储，关闭浏览器消失，localstorage永久存储
* cookie会发送到服务端，存储在内存中，sessionstorage存储在内存，localstorage只存储在浏览器端
* 路径：cookie有路径限制，storage只存储在域名下
* API：cookie没有特定的API，storage有特定的API

### typeof可以区分哪些类型
* 识别所有值类型
* 识别函数
* 判断是否是引用类型（不可再区分）

### 浏览器事件机制中，事件触发的三个阶段
* 捕获阶段：事件从根节点流向目标节点，途中流经各个DOM节点，在各个节点上触发捕获事件，直到达到目标节点
* 目标阶段：事件到达目标节点时，就到了目标阶段，事件在目标节点上被触发
* 冒泡阶段：事件在目标节点上触发后，不会终止，一层层向上冒，回溯到根节点

### javascript中for of和for in的区别
* 推荐循环对象使用for in，遍历数组使用for of
* for in循环出是key，for of循环出是value
* for of是ES6引入修复了for in的不足
* for of不能遍历普通对象，需要通过和Object,keys()搭配使用

### 同步机制有哪些
* 临界区，互斥对象，信号量，事件对象

### 同步与异步的区别
* 异步基于js单线程
* 异步不会阻塞代码的执行，同步会阻塞代码的执行
* 执行顺序：同步 -》微任务（promise） -》宏任务（settimeout）

### DOM是那种数据结构
* DOM树，树形结构

### attribute和propert的区别
* propert：修改对象属性，不会提现到html结构中
* attribute：修改html属性，会改变html结构
* 两者都可能引起DOM重新渲染，尽量使用propert

### 一次性插入多个DOM，怎样优化
* 可以使用createDocumentFragment进行操作
* 考虑dom节点的缓存，尽可能先获取所有的然后进行缓存，然后通过缓存进行操作，尽可能不边操作边获取dom

### 如何减少DOM操作
* 缓存DOM查询结果
* 多次DOM操作，合并到一次插入


### 编写一个通用的监听函数
```javascript
function bindEvent (elem, type, select, fun) {
  // 判断是否有回调
  if (fun == null) {
    fun = select // 没有回调，fun等于第三个参数
    select = null // 第三个参数为null
  }
  elem.addEventListener(type, event => {
    // 判断是否有第三个参数
    if (select) {
      // 代理绑定
      if (event.target.matches(select)) {
        fun.call(elem, event)
      }
    } else {
      // 普通绑定
      fun.call(elem, event)
    }
  })
}

bindEvent(div, 'click', 'button', () => {
  console.log('1')
})
bindEvent(div, 'click', () => {
  console.log('1')
})
```

### 描述冒泡事件流程
* 基于DOM树形结构
* 事件会顺着触发元素向上冒泡
* 应用场景：代理

### 无限下拉的图片列表，如何监听每个图片的点击
* 事件代理
* 用e.target获取触发元素
* 用matches来判断是否触发元素

### 手写ajax
* get

```javascript
const xhr = new XMLHttpRequest()
xhr.open('GET', 'city.json', true)
xhr.onreadystatechange = () => {
  if (xhr.readyState === 4) {
    if (xhr.status === 200) {
      console.log(JSON.parse(xhr.responseText))
    }
  }
}
xhr.send(null)
```

* post：发送内容为字符串而不是json

```javascript
const xhr = new XMLHttpRequest()
// false：同步。true：异步
xhr.open('POST', 'city.json', true)
xhr.onreadystatechange = () => {
  if (xhr.readyState === 4) {
    if (xhr.status === 200) {
      console.log(JSON.parse(xhr.responseText))
    }
  }
}
const data = {
  name: 'byron',
  password: '123'
}
xhr.send(JSON.stringify(data))
```

* xhr.readyState:
0：未初始化，还没有调用send()方法
1：载入，以调用send()方法，正在发送请求
2：载入完成 send()方法执行完成，已经接收到全部响应内容
3:   交互，正在解析响应内容
4：完成，响应内容解析完成，可以在客户端调用

* xhr.status：http状态码
2xx：表示成功的处理
3xx：需要重定向，浏览器直接跳转，301，302，304
4xx：客户端请求错误，404，403
5xx：服务端错误

### 跨域部分
* 同源策略：ajax请求时，浏览器要求当前网页和server必须同源（安全）同源：协议，域名，端口，三者必须一致
* 加载ims，css，js可以无视同源策略，jsonp

### 解释 JSONP原理，为何不是真正的ajax
* script 可以绕过浏览器的跨域限制，jsonp只能使用get
* 服务器可以任意动态拼接数据返回
* script 可以获得跨域的数据，只要服务端愿意返回
* script，img标签都可以绕过跨域

```javascript
// 手写简易jsonp
// 第一步创建jsonp.js文件并添加服务
callback(
  {
    name: 'byron'
  }
)
// 第二步在html文件中使用script调用该jsonp.js的地址（说加载脚本，实则获取数据）
<!DOCTYPE html>
<html>
<head>
  <title>jsonp</title>
</head>
<body>
<script>
  window.callback = (data) => {
    console.log(data)
  }
</script>
<script type="text/javascript" src="http://localhost:5501/data/jsonp.js"></script>
</body>
</html>
```

### CORS
* 在后端进行设置，前端可以直接进行访问

```javascript
// 第二个参数填写允许跨域名称，不建议直接写'*'
Response.setHeader('Access-Control-Allow-Origin', 'http://localhost:8081')
Response.setHeader('Access-Control-Allow-Header', 'X-Requested-With')
Response.setHeader('Access-Control-Allow-Methods', 'PUT,POST,GET,DELETE,OPTIONS')
// 接收跨域的cookie
Response.setHeader('Access-Control-Allow-Credentials', 'true')
```

### 描述cookie，localstorage，sessionstorage区别
* cookie：本身用于浏览器和server通讯，被借用到本地来存储，使用document.cookie进行访问赋值，最大存储4kb
* localstorage（永久存储），sessionstorage（会话存储）最大存储5M，不会随着http请求发送吗，setItem，getItem为api

### 经典面试题
```javascript
let test = {
  name: 'test',
  say: function () {
    console.log(this.name) // test
  },
  says: () => {
    console.log(this.name) // undefined
  }
}
test.say()
test.says()
```

### window.onload和DOMContentLoaded的区别
* window.onload：页面全部资源加载完成才会执行，包括图片，视频等
* DOMContentLoaded：DOM渲染完即可执行，此时图片，视频可能还没有加载完

### 防抖（频繁操作，最后进行触发）
* 监听一个输入框，文字变化后触发change事件
* 直接用keyup事件，则会频繁触发change事件
* 防抖：当用户输入结束或暂停时，才会触发change事件

```javascript
// 手写防抖函数
    function debounce(fun, delay = 500) {
      let timer = null
      return function () {
        if (timer) {
          clearTimeout(timer)
        }
        timer = setTimeout(() => {
          fun.apply(this, arguments)
          timer = null
        }, delay)
      }
    }

    input1.addEventListener('keyup',debounce(function () {
      console.log(this.value)
    }, 2000))
```

### 节流（频繁操作，保持一个频率连续触发）
* 拖拽一个元素时，要随时拿到元素被拖拽的位置
* 直接用drag事件，则会实时触发，很容易导致卡顿
* 节流：无论拖拽速度多快，都会每隔100ms触发一次

```javascript
// 手写节流函数
    function throttle(fun, delay = 500) {
      let timer = null
      return function () {
        if (timer) {
          return
        }
        timer = setTimeout(() => {
          fun.apply(this, arguments)
          timer = null
        }, delay)
      }
    }
    div1.addEventListener('drag', throttle(function (e) {
      console.log(e.offsetX, e.offsetY)
    }, 100))
```

### ES5和ES6实现每隔一秒打印一个数字
```javascript
  // ES6
  for (let i = 0; i < arr.length; i++) {
    setTimeout(() => {
        console.log(arr[i])
    }, 1000 * i)
  }
  // ES5
  for (var i = 0; i < arr.length; i++) {
    (function(i){
      setTimeout(function(){
        console.log(arr[i])
      }, 1000 * i)
    })(i)
  }
```

### 函数call和apply的区别
* 传参方式不同，call是依次传递参数，apply是传递一个数组

### 闭包是什么，有何特性，有何影响
* 闭包就是能够访问其他函数作用域中的变量
* 延长了变量的作用范围，加强封装性，可以达到对变量的保护
* 变量会常驻内存，得不到释放，闭包不要乱用

### 函数声明和函数表达式的区别
* 函数声明：function fun () {}
* 函数表达式：const fun = function () {}
* 函数声明会在代码执行前预加载，而函数表达式不会

### new Object()和Object.create()区别
* {}等同于new Object()，原型Object.prototype
* Object.create(null)没有原型
* Object.create({})可以指定原型，且当前变量的__proto__等于指定变量

```javascript
const obj1 = {
    a: 10,
    b: 20,
    sum () {
      return this.a + this.b
    }
  }

  const obj2 = new Object({
    a: 10,
    b: 20,
    sum () {
      return this.a + this.b
    }
  })

  // const obj2 = new Object(obj1) // obj1 === obj2  true
  const obj3 = Object.create(null) // {} 没有原型
  const obj4 = new Object() // {} 有原型
  const obj5 = Object.create( { // {} 有原型,且内容在原型中
    a: 10,
    b: 20,
    sum () {
      return this.a + this.b
    }
  })
  const obj6 = Object.create(obj1) // obj6.__proto__ === obj1 true
```

### http方法有哪些
* get/post/put/delete/head/options

### get/post的区别
* 参数：
>get传递参数只能在url后面，文本格式为QueryString
>post可以传递application/x-www-form-urlencoded的类似QueryString、multipart/form-data的二进制报文格式

* 用途：
>get用于从服务器端获取数据，包括静态资源（html/js/css/image等），动态资源（列表数据，详情数据）
>post用于向服务器提交数据，比如增删改数据，提交一个表单或者新建/修改一个用户

* 缓存：
>get默认会复用前面的请求数据作为缓存结果返回，解决方案：可以在url后面添加一个随机参数来进行更新缓存
>post一般不会呗缓存因素影响

* 安全性:
>get：明文传输
>post：密文传输，相对来说更安全，但是安全的前提是正确使用二者

### ES6中import和commonJS中require的区别
* import是ES6写法，最终会转换为require，require遵循commonJS模块化解决方案
* ES6模块是编译时输出接口，commonJS模块是运行时加载
* ES6模块是动态引用，即导入和导出的值都指向同一个内存地址，所以导入的值会随着导出值变化。CommonJs的模块是对象。导出时是指拷贝，就算导出的值变化了，导入的值也不会变化，如果想要更新值就要重新导入
* import语句导入同一个模块如果加载多次只执行一次，require语句导入次数和实际执行次数相同
* import必须用在当前模块的顶层，如果在局部作用域内，会报错，es6这样的设计可以提高编译器效率，但没法实现运行时加载。require可以用在代码的任何地方
* import是关键词，require不是关键词
* require支持动态引入，也就是require(${path}/xx.js)，import目前不支持，但是已有提案

### 手写字符串trim写法
```javascript
String.prototype.trim = function() {
    return this.replace(/^\s+/, '').replace(/\s+$/, '')
  }
```

### 如何捕获js中的异常
* try{} catch(e){}
* window.onerror

### 获取url参数
```javascript
function query(name){
    const search = location.search
    const p = new URLSearchParams(search)
    return p.get(name)
  }
  // http://127.0.0.1:5501/jsInterview/32-query.html?b=%27123%27
  console.log(query('b')) // '123'
```

### 手写flag函数
```javascript
function flag(arr) {
    // 判断是否有二维数组
    let isDeep = arr.some(item => item instanceof Array)
    if(!isDeep) {
      return arr
    }
    const res = Array.prototype.concat.apply([], arr)
    return flag(res)
  }

  let arr = [1, [2, [3, [4, [5]]]]]
  console.log(flag(arr))
```

### 有以下3个判断数组的方法，分别输出什么
```javascript
let arr = [1, 2, 3]
// Object.prototype.toString.call()
console.log(Object.prototype.toString.call(arr)) // [object Array]
// instanceof 既可以判断父类也可以判断子类
console.log(arr instanceof Array) // trur
// Array.isArray(arr) // 可以用于prototype
console.log(Array.isArray(arr)) // trur
```




## 运行环境
### git
### 调试工具
### 抓包工具
### webpack babel
### linux基本命令

### 网页加载过程
#### 从输入url到渲染页面的整个过程
* DNS解析：域名 -> ip地址
* 浏览器根据ip地址向服务器发起http请求
* 服务器处理http请求，并返回给浏览器
* 根据HTML代码生成DOM Tree
* 根据css代码生成CSSOM
* 根据DOM Tree和CSSOM整合形成Render Tree
* 根据Render Tree渲染页面
* 遇到script则暂停渲染，优先加载执行js代码，完成后再继续
* 直至把Render Tree渲染完成

### 性能优化
* 多使用内存，缓存其他方法，（图片懒加载）
* 减少cpu计算量，减少网络加载耗时
* 加载更快
>减少资源体积，压缩代码
>减少访问次数，合并代码，ssr服务器端渲染，缓存
>使用更快的网络：CDN

* 渲染更快
>css放在header，js放在body最下面
>懒加载
>尽早开始执行js，用DOMContentLoaded触发
>对DOM查询进行缓存
>频繁DOM操作，合并到一起插入到DOM结构
>节流throttle	防抖debounce

### 常见的web前端攻击方式有哪些
* XSS跨转请求攻击

```shell
#模拟场景
#1:一个博客网站，我发表一篇博客并嵌入<script>脚本
#2:脚本内容：获取cookie，发送到我的服务器，我的服务器配合跨域
#3:发乎这篇博客后，有人查看他，从而我获取到访问者的cookie
#预防XSS，可以使用npm的xss包来做这些事情
#1:替换特殊字符，如<变为&lt; >变为&gt;
#2:<script>变为&lt;script&gt;，直接显示，而不会被作为脚本运行
#3:前后端都需要做替换
```

* CSRF/XSRF跨站请求伪造

```shell
#模拟场景
#1:你正在购物，看中了某个商品，商品id是100
#2:付费接口是xxx.com/pay?id=100, 但是没有验证
#3:我是攻击者，我看中一个商品，id是200
#4:我向你发送一封电子邮件
#5:邮件正文隐藏这<img src=xxx.com/pay?id=200 />
#6:你一查看邮件，就帮我购买了id为200的商品
#预防XSRF
#1:使用POST接口
#2:增加验证，例如密码，短信验证，指纹，人脸识别
```


## 计算机网络部分
### 七层协议
* 物理层
* 数据链路层	mac地址
* 网络层	ip
* 传输层	tcp
* 会话层
* 表现层
* 应用层	http

### 当用户输入网址后发生了什么
* 协议、主机、端口、路径
* 当输入地址后，浏览器会先查到缓存（浏览器/系统/路由/web服务缓存），如果有缓存，那么就会直接在缓存中进行读取，不会调取服务器的数据，如果没有缓存，那么就要去服务器中获取数据，（DNS解析 ）通过域名解析出ip，ip对应的一台服务器，找到服务器后，浏览器要与web服务建立连接，建立连接通过后，浏览器就会向服务器发送请求，服务器需要安装web服务，否则无法建立连接，然后进行TCP三次握手，握手通过后，web服务会给浏览器发送一个页面标签地址内容，浏览器拿到后进行渲染，首先先根据html标签绘制一个dom树，css会生成一个cssdom树，最后生成render树，然后从上到下依次进行执行，如果是外部连接会同时发送并列请求
* 详细版：
>1、浏览器会开启一个线程来处理这个请求，对URL 分析判断如果是http协议就按照Web方式来处理
>2、调用浏览器内核中对应的方法，比如WebView中的loadUrl方法
>3、通过DNS解析获取网址的ip地址，设置UA等信息发出第二个GET请求
>4、进行HTTP协议会话，客户端发送报头（请求报头）
>5、进入到web服务器上的WebServer,如Apache，Tomcat，Nodejs，Nginx等服务器
>6、进入部署好的后端应用，如PHP、java、JavaScript、python等，找到对用的请求处理、
>7、处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回会304

### http与https的区别
* http不安全，默认端口为80，https安全，默认端口为443
* http在osi网络模型的最高层应用层，https有安全机制在传输层完成
* 七层模型：（物数网传会表应）
* http直接发布即可，https需要申请SSL证书

### 什么是http无状态协议，以及怎样解决
* 无状态协议：没有记忆功能，一次http请求结束后就结束了，没有记忆能力，第二次请求取不回上次的数据
* 解决方案：session，cookie，html5新特性本地存储

### http工作原理
1.浏览器将自己支持的一套加密规则发送给网站。
2.网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。
3.浏览器获得网站证书之后浏览器要做以下工作：
a) 验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。
b) 如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密。
c) 使用约定好的HASH算法计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。
4.网站接收浏览器发来的数据之后要做以下的操作：
a) 使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。
b) 使用密码加密一段握手消息，发送给浏览器。
5.浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。

![](http://ww3.sinaimg.cn/large/7cc829d3gw1f7xujtsfmhj20bu0cuq3k.jpg)

### http有哪些状态码
* 100：Continue继续。客户端应继续其请求，101：切换协议
* 200：正常
* 301：永久重定向
* 302：临时重定向
* 403：禁止被访问
* 404：找不见资源
* 500：服务器内部错误
* 503：服务器超载或无法处理请求

### 常用的http的header字段
* Accept：设置接收的内容类型
* Accept-Charset：设置接收的字符编码
* Expires：设置响应体过期事件
* Content-Type：设置响应体的MIME类型
* Date：设置响应体的过期时间
* Set-Cookie：设置HTTP Cookie
* Status：设置HTTP响应状态

### 什么是TCP协议
* 面向连接的可靠的传输协议

### 三次握手（建立连接）
* 第一步：客户端向服务端发送syn包
* 第二步：服务端接收后，向客户端发送syn+ack包
* 第三步：客户端向服务端发送ack包，完成三次握手，成功建立连接

### 四次挥手（断开连接）
* 第一步：客户端向服务端发送FIN需要断开连接
* 第二步：服务端基于可靠性向客户端发送FIN+ACK
* 第三步：服务端向客户端发送FIN需要断开连接
* 第四步：客户端向服务端发送ACK，然后资源销毁

### 当一个服务端对应多个客户端为什么不会发错数据
* 是因为socket的四元组即ip+port ip+port，四个只要有一个不同就能够进行区分

### http1.0与http1.1与http2.0区别
* 1.0：短连接（100张图，100次tcp握手和挥手）
* 1.1：长连接（100张图，1次tcp握手挥手）
* 2.0：长连接+io多路复用模型

### RPC和Http的区别
* 性能：rpc通过thrift二进制传输，http通过json序列化更消耗性能
* 传输协议：rcp基于tcp也可以基于http，http只能是http协议
* 负载均衡：rpc自带负载均衡，http需要自己配置（nginx）
* 传输效率：rpc可以自定义tcp协议，报文相对较小，http有很多无用的东西（很多头部信息）
* 通知：rpc自行通知，http事先通知，自行修改nginx配置或者其他负载均衡的配置

### TCP与UDP的区别
* 基于连接与无连接；
* 对系统资源的要求（TCP较多，UDP少）
* UDP程序结构较简单
* 流模式与数据报模式
* TCP保证数据正确性，UDP可能丢包
* TCP保证数据顺序，UDP不保证

### https加密原理
* 采用加密、数字证书、数字签名的技术来实现
#### 加密算法
* 对称加密：客户端与服务端公用一个密钥来对消息加密，客户端与服务端约定好一个加密的密钥，客户端发消息前用该密钥对消息加密，发送给服务端，然后服务端用该密钥解密拿到信息
>优点：对称加密解决了http中消息保密性问题
>缺点：因为同用一个密钥，使得密钥很容易泄露，难以保证消息来源的可靠性，完整性，准确性

* 非对称加密：客户端与服务端均有一个公钥和私钥，使用公钥加密，需要使用对用的私钥进行解密，相反也是，当客户端发送消息时，先使用服务端公钥加密，服务端接收后使用自己的私钥进行解密
>优点：解决了http中消息保密的问题，使私钥泄露的风险降低，因为公钥加密的消息只有对应的私钥才能解开，所以大大程度上保证了消息的来源性以及消息的准确性，完整性
>缺点：非对称加密需要使用到接收方的公钥对消息进行加密，但是公钥不是保密的，任何人都可以获取，中间人也可以获取。那么中间人就可以做两件事，第一件：可以在客户端与服务端交换公钥时，将客户端的公钥替换为自己的，这样服务端拿到的公钥就不是客户端的，而是中间人的，服务端也无法判断公钥来源的正确性，第二件：中间人可以不替换公钥，但是可以截取客户端发送的信息，修改信息，然后用服务端的公钥加密发往服务器上，从而服务端接收到错的消息。非对称加密的性能要比对称加密的性能慢几倍至上百倍，比较消耗资源，正因如此，https将两种加密结合起来

### http的缓存有哪几种
* 强制缓存
* 协商缓存
* 通过文件内容缓存

### 进程与线程
* 一个程序至少有一个进程，一个进程至少有一个线程
* 内存对资源分配的最小单位是进程，而进程执行的最小单位是线程
* 线程是不能够脱离进程而独立运行的
* 当进程运行时只产生一个线程时，被称为单线程，否则被称为多线程
* 单线程与多线程都是指的在同一进程当中的单或多
* 线程越多意味着你在一个进程中同时执行的任务也就越多

### 二叉树、满二叉树与完全二叉树
* 二叉树：除了叶子结点外，每个结点只有两个分支，左子树和右子树，每个结点最大度数为2
* 满二叉树：除了叶结点外的每一个结点都有左右子结点且叶结点都处于二叉树的最底层
* 完全二叉树：只有最下面的两层结点度小于2，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树

### 算法排序
|类别|排序方法|时间复杂度|空间复杂度|稳定性|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|插入排序|直接插入|1|1|1|1|1|







## Vue面试题
### 为什么v=for中用key
* 必须使用key，且不能使用index
* diff算法中通过tag和key来判断，是否是sameNode
* 减少渲染次数，提升渲染性能

### computed有何特点
* 缓存，data不变不会重新计算
* 提高性能

### 如何将所有的props传递给子组件
* 使用$props
```javascript
<user v-bind='$props' />
```

### vue的生命周期
* bforeCreate：创建之前
* created：创建完成之后 // 初始化实例，并没有开始渲染
* beforeMount：挂载之前
* Mounted：挂载完成 // 页面绘制完成了，一般用来获取网络数据
* beforeUpdate：更新之前
* updated：更新完成
* beforeDestroy：销毁之前 // 解除自定义绑定事件，清除定时器，解除DOM事件
* destroyed：销毁完成
#### 父子组件间生命周期执行顺序
* 创建与挂载
>父组件：create
>子组件：create
>子组件：mounted
>父组件：mounted

* 更新前与更新
>父组件：beforeUpdate
>子组件：beforeUpdate
>子组件：updated
>父组件：updated

* 销毁前与销毁
>父组件：beforeDestroy
>子组件：beforeDestroy
>子组件：destroyed
>父组件：destoryed

### 如何理解MVVM
数据驱动视图
传统组件，只是静态渲染，更新还需要依赖DOM

### vue组件如何通讯
* 父到子：props
* 子到父：$emit
* 兄弟组件：bus总线，event.$on,event.$off,event.$emit
* vuex

### 描述组件渲染的更新过程，模板编译
* 编写template模板，然后通过某种方式（vue-template-compiler）生成render函数，然后执行render函数生成vnode，然后再渲染到页面
* 初次渲染过程：
1、解析模板为render函数（或在开发环境已完成，vue-loader）
2、触发响应式，监听data属性getter setter
3、执行render函数，生成vnode，path(elem，vnode)
* 更新过程
1、修改data，触发setter（此前getter已被监听）
2、重新执行render函数，生成newVnode
3、path(vnode，newVnode)
* 异步渲染（$nextTick）：汇总data的修改，一次性更新视图，减少DOM操作次数，提高性能

### 双向绑定v-model的实现原理，响应式
* 核心API：Object.defineProperty（vue3.0启用Proxy）
* Object.defineProperty缺陷：对原始数据进行克隆，需要分别给对象中的每一个属性设置监听

### vdom与diff算法，vdom
#### diff算法
* 只比较同一层，不跨级比较
* tag不相同，则直接删掉重建，不再深度比较
* tag和key两者都相同，则认为是相同节点，不再深度比较

### vue路由
* hash路由：
>hash变化会触发页面跳转，即浏览器的前进，后退
>hash变化不会刷新页面，SPA（单页面）必需的特点
>hash永远不会提交到server端
>一般用于toB的系统，简单易用，对url不敏感

```javascript
// 手写hash
// hash 变化，包括：
    // a. JS 修改 url
    // b. 手动修改 url 的 hash
    // c. 浏览器前进、后退
    window.onhashchange = (event) => {
      console.log(`old url:${event.oldURL}`)
      console.log(`new url:${event.newURL}`)
      console.log(`hash:${location.hash}`)
      console.log(event)
    }

    document,addEventListener('DOMContentLoaded', () => {
      console.log(`hash:${location.hash}`)
    })
    btn1.addEventListener('click', () => {
      location.href = '#/user'
    })
```

* history路由（需要后端的支持）
>用url规范的路由，但跳转时不刷新页面
>toC的系统可以考虑使用，但需要服务端的支持

```javascript
// 手写history
// 页面初次加载，获取path
  document.addEventListener('DOMContentLoaded', () => {
    console.log(`load:${location.pathname}`)
  })

  // 打开一个新的路由
  // 注意哦 用pushState方式，浏览器不会刷新页面
  btn1.addEventListener('click', () => {
    const state = { name: 'page1' }
    console.log('切换路由到page1')
    history.pushState(state, '', 'page1')
  })

  // 监听浏览器的前进 后退
  window.onpopstate = (event) => {
    console.log(event)
    console.log(`onpopstate`, event.state, location.pathname)
  }
```

### vue常见的性能优化
* 合理使用v-show和v-if
* 合理使用computed
* v-for中添加key，避免与v-if的同时使用
* 自定义事件，DOM事件及时销毁
* 合理使用异步组件
* 合理使用keep-alive
* data层级尽量不要太深
* 使用vue-loader在开发环境做模板编译（预编译）
* 使用ssr


## React面试题
### react的生命周期
* constructor()：初始化阶段
* componentWillMount()：挂载阶段
* render()：
* componentDidMount()：ui渲染完成，一般用来获取外部数据
* shouldComponentUpdate()：对比值，确定是否需要进行渲染
* componentDidUpdate()：组件更新后触发
* componentWillUnmount()：组件移除时调用，可以用来资源释放

### react组件如何通信
* 父 -> 子组件使用props
* 子 -> 父组件自定义事件
* Redux和Context

### jsx本质是什么
* jsx可以理解为vue的template模板，但不是模板，本身是js的语法糖
* jsx会通过react.createElement会返回vnode
* vnode通过path(elem，vnode)，path(vnode， newVnode)渲染和更新到页面中

### context是什么，有和用途
* 可以获取父级传递的内容，从而不用props一层一层向下传递

```javascript
// 父组件
import React, { Fragment } from 'react';
import ProtalsDemo from './ProtalsDemo';

// React.createContext：创建一个上下文的容器(组件)
export const { Provider,Consumer } = React.createContext() 
const BaseUser = () => {
  return (
  	{value：定义传递内容}
    <Provider value='上下文'>
        <ProtalsDemo children='Protals' />
    </Provider>
  )
}
export default BaseUser

// 子组件
import React from 'react'
import ReactDOM from 'react-dom'
// 调用父级的Consumer进行使用父级传递的值
import { Consumer } from './index'

class ProtalsDemo extends React.Component {
    constructor(props) {
        super(props)
    }
    render() {
        return (
          <div className="modal">
            <Consumer>
              {value => <p>{value}</p>}
            </Consumer>
          </div>
        ) 
    }
}
export default ProtalsDemo
```

### shouldComponentUpdate（scu）的用途
* React默认父组件有更新，子组件无条件更新
* SCU不一定每次都要使用
* 必须配合不可变值一起使用

### 描述redux单项数据流
* 组件通过dispatch发送action给store，store调用传入reducer中，reducer进行数据的更新然后返回给store一个新的store，然后store保存更新数据，view调用store数据

### 什么是纯函数
* 返回一个新值，输入数组返回数组，输入对象返回对象
* 不可变值

### setState是同步还是异步
* 不可变值
* 可能是异步更新，正常使用是异步更新，但是在定时器和自定义的DOM事件上是同步更新
* 可能会合并，当连续的赋值对象时候，会进行合并，当连续的函数调用不会合并
* setState其实无所谓异步还是同步的，主要是看isBatchingUpdates是否为true，如果为true则是异步，如果为false则为同步，isBatchingUpdates在setState执行前设置为true，执行后设置为false

### batchUpdate机制
#### 那些能够命中batchUpdate机制
* 生命周期（以及调用的函数）
* React中注册的事件
* React可以管理的入口

#### 那不些能够命中batchUpdate机制
* setTimeout，setInterval等
* 自定义DOM事件
* React管不到的入口

### react和vue的区别
####  共同点
* 都支持组件化
* 都是数据驱动视图
* 都使用vdom操作DOM
#### 不同点
* React使用JSX拥抱js，Vue使用模板拥抱html
* React函数式编程，Vue声明式编程
* React更多的需要自力更生，Vue把想要的都给开发者（eg：循环react使用map，vue使用v-for）

### React Hooks与生命周期的关系
* Hooks组件，即使用了Hooks的函数组件，有生命周期
|class组件|Hooks组件|
|-|-|
|constructor|useState|
|getDerivedStateFromProps|useState里面update函数|
|shouldComponentUpdate|useMemo|
|render|函数本身|
|componentDidMount|useEffect，useEffect(fn, [])|
|componentDidUpdate|useEffect|
|componentWillUnmount|useEffect|

### React中`<Link>`与a标签有什么区别
* link应用范围更广，不会刷新页面，
* a：刷新页面



## Webpack面试题
### 前端代码为何要进行构建和打包
### module chunk bundle分别是什么意思，有何区别
### loader和plugin的区别l
### webpack如何实现懒加载
### webpack常见的性能优化
### babel-runtime和babel-polyfill的区别

## Node面试题
### 介绍一下npm模块安装机制，为什么输入npm install 就可以自动安装对应的模块
* 当实用npm安装模块时会把依赖信息安装到package.json中，当使用npm install后自动到package.json上找到依赖项进行安装模块



# 字节跳动提前批前端实习生一面总结
## 题目
### jsx怎样生成DOM并渲染到页面的，template怎样生成DOM并渲染到页面的
### 虚拟dom怎样生成真实dom的
### vue中Object.defineProperty 为什么不能检测数组的改变
### 微任务，宏任务怎么理解，哪些是微任务，哪些是宏任务
### ES6语法转ES5语法问题，ES6clss转为ES5怎样写

## 面试经验
* 首先开始介绍自己要向着自己的优势方向介绍，这样可以让面试官优先问你自己的优势处，这次的自我介绍还行，就是介绍项目的亮点给介绍倒了react hooks上，然后面试开始问react，闻到了自己相对弱的地方，很难受，还有注重原理，大厂真的很爱问原理，注重基础方面



























