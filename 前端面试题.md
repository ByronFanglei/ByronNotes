# 前端面试概述题
## HTML部分
### HTML常见的块级元素与行级元素
* 行级：不能设置宽高（内容撑开），水平排列【span，a，i，b，strong，em】
* 块级：可以设置宽高，垂直排列，独占一行【div，p，ul，li，h1，ol】
* 行内块：元素在一行显示，可以给行内块元素设置宽度和高度【input，img】
* display：block，inline，inline-block	即可以设置宽高，又可以水平分布
### HTML5 有哪些新特性？
* 不需要任何插件就可以实现动画，视频，图形等效果，替代flash插件
* 声明方式
>HTML4 规定了三种声明方式，分别是：严格模式Strict、过渡模式Transitional  和 框架集模式Frameset
>而HTML5因为不是SGML的子集，只需要<!DOCTYPE html>就可以了

* 语义化更好的内容标签：header，footer，article，aside，section，details，summary，dialog，nav，有助于SEO的优化
* 音频，视频：audio，video，【提醒，MP4在h5可能存在声音和视频不同步的问题，大概是4s】
* HTML5 拥有多个新的表单输入类型。这些新特性提供了更好的输入控制和验证：color，date，datetime，datetime-local，email，month，number，range，search，tel，time，url，week
* 本地存储/离线存储API：
>长期存储数据的 localStorage	比较常用
>临时存储的 sessionStorage，浏览器关闭后自动删除	不常用

* 地理API：Geolocation
* 拖拽释放API
* Web Workers
* websocket（不断开链接）很适合做网页版的聊天工具

### HTML5 引入什么新的表单属性
* form：
>autocomplete:属性规定表单是否应该启用自动完成功能  《form autocomplete="on|off"》
>novalidate:如果使用该属性，则提交表单时不进行内容的验证	novalidate="novalidate"

* input:
>autocomplete：属性规定表单是否应该启用自动完成功能，大意可以查看之前输入的内容
>autofocus：加载页面后，自动获取光标
>list：引用包含输入字段的预定义选项的 datalist 
>min 和 max：min 属性与 max 属性配合使用，可创建合法值范围，两个要一对用
>pattern ：规定用于验证输入字段的正则表达式
>placeholder：提供可描述输入字段预期值的提示信息
>required：规定必需在提交之前填写输入字段。 如果使用该属性，则字段是必填（或必选）的
>step：为输入域规定合法的数字间隔。 如果 step=“3”，则合法的数是 -3,0,3,6 等

### 与 HTML4 相比 HTML5 废弃了哪些元素
* basefont、big、center、font、s、strike、tt、u、frame、frameset、noframes

###	如何处理 HTML5 新标签的浏览器兼容问题
```javascript
<!--[if lt IE 9]>
<script type="text/javascript" src="js/html5shiv.js"></script>
<![endif]-->
```

### URI与URL的区别
* URI：统一资源标识符，标识一个资源
* URL：统一资源定位器，就是一个具体的url
* URL包含（协议，ip或域名，端口，目录，文件名）


## CSS部分
### CSS单位解释.
* px：绝对单位，页面按精确像素展示
* em：相对单位，基准为父节点字体的大小
* rem：相对单位：基准为html的字体大小
* vm：视窗宽度，1vm等于视窗宽度1%
* vh：视窗高度，1vh等于视窗高度1%

### 什么是响应式布局，响应式布局有哪些
* 响应式布局就是一个网站能够兼容多个终端，而不是每个终端都做一个特定的版本
* 等比例缩放，媒体查询

### bootstrap响应式布局原理
* 百分比布局+媒体查询

### BFC
* BFC：块级格式化上下文，它是一个独立的渲染区域，
* BFC规则：
>内部的box会在垂直方向，一个接一个的放置
>box垂直方向的距离有margin决定，属于同一个BFC的两个相邻box的margin会发生重叠
>每个元素的margin box的左边，与包含块border box的左边相接触 即使在浮动也如此
>BFC的区域不会与float box重叠
>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之也如此
>计算BFC的高度时，浮动元素也参与计算

* 创建BFC的方法：
>position：absolute或者fixed
>float：不是none
>overflow： 不为visible
>display： inline-block或者flex，table-cell，table-caption，inline-flex
>根元素：html元素

### 盒子垂直居中的方法
* 表格居中
* flex居中
* 绝对定位居中
* grid布局

### link与@import区别
* link是html代码
* @import是css代码，可以写在html代码中，会阻塞页面的渲染，不推荐

### css常见的选择器
* id，class， 标签【p】
* 后代选择器【div p】，子代选择器【div>p】，紧邻选择器【div+p】，匹配任何在div元素之后的同级p元素【div~p】，分组选择器【div，p】
* 伪类选择器 :hover{}，伪元素选择器::after
* 属性选择器 div[a]

### css的优先级
* !important > 内联 > id选择器 > class选择器 > 标签选择器

### 浮动问题
* 清除浮动的方式：
1、在浮动的元素下面添加一个标签，添加属性clear：both；
2、添加clearfix样式，原理与上一样，添加after伪元素并设置 content: "";display: block; clear:both
3、父元素添加overflow:hidden
4、父元素 float

### 定位问题 position
* static：默认的
* absolute：绝对定位，相对于最近已定位的祖先元素，定位后空间释放，对行内元素使用后变为块级元素
* relative：相对定位，相对于自己初始位置，定位后空间不释放
* fixed：固定定位，相对于浏览器定位，定位后空间释放，对行内元素使用后变为块级元素
* sticky：粘性定位，相当与吸顶效果

### 盒模型
* 标准盒模型：width属性 = content宽度
* 怪异盒模型：width属性 = content + padding + border宽度
* box-sizing: content-box 标准盒模型，border-box怪异盒模型

### 外边距合并问题
* 父元素添加overflow:hidden
* 父元素浮动或定位
* 子元素浮动或定位
* 父元素添加边框

### 重绘 重排
* 重绘：一个元素的外边被改变，但是没有改变布局，的情况下发生，如改变visibility，outline，背景色等
* 重排/reflow（回流）：当浏览器某个部分发生了变化影响了布局，需要倒回去重新渲染，DOM的变化影响到了元素的几何属性，浏览器会重新计算元素的几何属性，如改变窗口的大小，文字的大小，内容的改变，浏览器窗口变化，style属性的改变等，重绘不会引起重排，但重排一定会引起重绘
* 那种情况导致重绘：visibility、outline、背景色等属性
* 那种情况导致重排：页面渲染初始化时、浏览器窗口改变尺寸、元素尺寸改变时、元素位置改变时、元素内容改变时、添加或删除可见的DOM 元素时，获取offsetLeft等
* 怎样减少重绘和重排：
>css部分：
1.避免频繁的样式操作，最好一次性的重写style或一次性更改class
2.避免设置多层内联样式
3.对具有复杂动画的元素进行绝对定位，使他脱离文档流，否则会引父元素及后续元素频繁回流
4.避免使用table布局
5.使用css3硬件加速，可以让`transform`、`opacity`、`filters`等动画效果不会引起重绘和重排

>js部分：
1.避免频繁操作DOM，可以使用createDocumentFragment创建子树，然后再拷贝到文档中
2.先隐藏元素，然后修改后再显示该元素，因为display:none上的DOM曹祖不会引起回流和重绘
3.避免循环读取offsetLeft等属性，在循环之前把他们存储起来

### display部分
* display：inline，block，inline-block，flex，table，table-cell

### 显示隐藏
* display：none，block	不占空间，没有事件
* opacity： 0， 1	占空间，有事件
* visibility： hidden， visible	占空间	没有事件

### viewport的作用
* 进行对移动端页面的适配，当加载页面后，先获取默认像素的页面，然后根据viewport的设置进行全局缩放，达到适配当前屏幕的页面

```html
<meta name="viewport" content="width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
```

### css画图形
* 画三角

```css
.one{
      width: 0;
      height: 0;
      border-left: 100px solid #ff6700;
      border-top: 50px solid transparent;
      border-right: 0;
      border-bottom: 50px solid transparent;
    }
```

* 画加号

```css
.one{
      width: 50px;
      height: 50px;
      border: 1px solid #ff6700;
      position: relative;
    }
    .one::before{
      content: "";
      position: absolute;
      left: 50%;
      top: 50%;
      width: 40px;
      border-top: 10px solid #ccc;
      transform: translate(-50%, -50%);
    }
    .one::after{
      content: "";
      position: absolute;
      left: 50%;
      top: 50%;
      height: 40px;
      border-left: 10px solid #ccc;
      transform: translate(-50%, -50%);
    }
```

## JavaScript部分
### JavaScript 中有几种数据类型
* 基本数据类型：String、Number、Boolean 、Undefined、Null、Symbol、BigInt 
* 引用数据类型：Object，其中Object可以分为：Array，Date 但是typeof可以识别出Function

### 查看数据类型
* typeof：只可以分辨出基本数据类型和引用数据类型，引用数据类型都为object

```javascript
console.log(typeof '') // string
console.log(typeof 1) // number
console.log(typeof true) // boolean
console.log(typeof Symbol()) // symbol
console.log(typeof undefined) // undefined
console.log(typeof function () {}) // function
console.log(typeof 11n) // bigint, 需要直接在浏览器中执行
console.log(typeof null) // object
console.log(typeof []) // object
console.log(typeof {}) // object
console.log(typeof new Date()) // object
console.log(typeof new RegExp()) // object
```

* instanceof：可以精准的检测引用数据类型

```javascript
console.log({} instanceof Object) // true
console.log([] instanceof Array) // true
console.log([] instanceof Object) // true
console.log('1' instanceof String) // false
console.log(new String('1') instanceof String) // true
```

```javascript
// 手写instanceof
function instance_of(L, R) {
    // 如果为基本数据类型直接返回false
    const arr = ['string', 'number', 'boolean', 'symbol', 'bigint', 'undefined']
    if (arr.includes(typeof L)) {
      return false
    }
    // 获取隐式原型
    L = L.__proto__
    // 获取显示原型
    const RR = R.prototype

    while(true) {
      // 当隐式原型为null 查找结束且没有找到
      if (L === null) {
        return false
      }
      // 当显示原型全等于隐式原型则返回true
      if (L === RR) {
        return true
      }
      // 没有找到继续向上一层原型查找
      L = L.__proto__
    }
  }
  console.log(instance_of([], Object))
```

* Object.prototype.toString.call()：可以精准的检测所有的数据类型

```javascript
console.log(Object.prototype.toString.call('')) // [object String]
console.log(Object.prototype.toString.call(1)) // [object Number]
console.log(Object.prototype.toString.call(true)) // [object Boolean]
console.log(Object.prototype.toString.call(Symbol())) // [object Symbol]
console.log(Object.prototype.toString.call(undefined)) // [object Undefined]
console.log(Object.prototype.toString.call(null)) // [object Null]
console.log(Object.prototype.toString.call(function () {})) // [object Function]
console.log(Object.prototype.toString.call([])) // [object Array]
console.log(Object.prototype.toString.call({})) // [object Object]
console.log(Object.prototype.toString.call(11n)) // [object BigInt], 需要直接在浏览器中执行
```

### 值类型和引用类型的区别
* 存储位置不同：值类型：栈，引用类型：堆
* 复制方式不同：值类型是深拷贝，引用类型则是浅拷贝
* 值类型无法添加属性，引用类型可以添加属性
* 值类型是比较值，引用类型是比较引用地址比较

### 类型转换
* 一般判断null，undefined使用== 其他一律使用===

### ==规则
* 对象==字符串：对象.toString()变为字符串
* null==underfined相等，但是和其他值比较就不在相等了
* NaN==NaN不相等
* 剩下的都转换为数组

### 列举强制类型转换和隐式类型转化
* 强制：parseInt，parseFloat，toString
* 隐式：if， 逻辑，==，+拼接字符串

### JavaScript 数据类型，null不存在的原因
* 不存在的原因：方法不存在，对象不存在，字符串变量不存在，接口类型对象没初始化
* 解决方法：做判断处理的时候，放在设定值的最前面
* null本质：null不是一个空引用，而是一个原始值，它只是期望此处用引用一个对象

```javascript
null == null // true
null === null // true
undefined === undefined // true
```

### JavaScript 什么叫全局变量?什么叫局部变量了?是如何定义出来的?
* 全局变量是在函数外部定义的变量,在JS中全局变量属于window对象,其作用域是整个源程序,全局变量全部存放在静态存储区,在程序开始执行时给全局变量分配存储区,程序运行完毕就释放。
  局部变量是相对与全局变量而言的,在特定过程或函数中可以访问的变量,作用域较小,当函数运行结束释放局部变量。

### JavaScript 书写规范/原则
>1.不要在同一行声明多个变量。
>2.请使用 === /!==来比较true/false或者数值
>3.使用对象字面量替代new Array这种形式
>4.尽量不使用全局函数。
>5.switch语句必须带有default分支
>6.函数不应该有时候有返回值，有时候没有返回值。
>7.for循环必须使用大括号
>8.if语句必须使用大括号
>9.for-in循环中的变量 应该使用let或const关键字明确限定作用域，从而避免作用域污染。

### JavaScript 说一说html代码,css代码和js代码的注释写法?
>HTML：<!--注释的内容-->
>CSS：/* 注释内容 */
>JS：//注释内容			/*注释内容*/

### JavaScript NaN是什么意思?这个值有什么特点?
>NaN 表示不是一个数,但是它本身是 number 类型。
>NaN 和 NaN 不相等

### JavaScript new操作符具体干了什么呢?
>创建一个空对象,并且 this 变量引用该对象,同时还继承了该函数的原型
>属性和方法被加入到 this 引用的对象中
>新创建的对象由 this 所引用,并且最后隐式的返回 this

```javascript
function Person(name) {
    this.name = name,
    this.say = function() {
      console.log(this.name)
    }
  }

  function _new(fun, ...arg) {
    // 1、创建一个空对象
    let obj = new Object()
    // 2、修改obj原型为fun的原型
    obj.__proto__ = fun.prototype
    // 3、修改this指向，并把参数传递过去
    let res = fun.call(obj, ...arg)
    // 4、根据规范，返回null和undefined不处理，依然返回obj
    return res instanceof Object ? res : obj
  }

  let byte = _new(Person, '字节跳动')
  byte.say()
```

### js装箱与拆箱
* 装箱：把基本数据类型转换为对应的引用数据类型的操作，（创建一个对象，在实例上调用方法，销毁实例）
* 拆箱：把引用类型转换为基本数据类型的操作

### 对JSON的了解?
>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式
>它是基于JavaScript的一个子集
>数据格式简单, 易于读写, 传输占用带宽小
>JSON对象包含两个方法: 用于解析 JSON 的 parse() 方法，以及将对象/值转换为 JSON字符串的 stringify() 方法	深拷贝
>除了这两个方法, JSON这个对象本身并没有其他作用，也不能被调用或者作为构造函数调用
>json的key和value支持的数据类型为：数组(array)、对象(object)、字符串(string)、数字(number)、布尔型(boolean)、NULL

### JavaScript document.write 和 innerHTML的区别?
>document.write 只能重绘整个页面
>innerHTML 可以重绘页面的一部分

### JavaScript 哪些操作会造成内存泄露?
* 什么是内存泄露：内存泄漏指任何对象在你不再拥有或需要它之后仍然存在
* 哪些操作会造成内存泄露
>setTimeout 的第一个参数使用字符串而非函数的话,会引发内存泄漏
>闭包
>控制台日志
>循环引用（在两个对象彼此引用且彼此保留时,就会产生一个循环）
>DOM插入顺序

* 如何检测
>最简单的检测内存泄漏的方式是用任务管理器检查内存使用情况。在Chrome浏览器的新选项卡中打开应用并查看内存使用量是不是越来越多

### JavaScript 什么是"use strict"?使用它的好处和坏处分别是什么?
* 严格模式
* 优点：
>消除Javascript语法的一些不合理、不严谨之处,减少一些怪异行为
>消除代码运行的一些不安全之处,保证代码运行的安全
>提高编译器效率,增加运行速度
>为未来新版本的Javascript做好铺垫，	经过测试 IE6,7,8,9 均不支持严格模式

* 缺点
>现在网站的 JS 都会进行压缩,一些文件用了严格模式,而另一些没有
>这时这些本来是严格模式的文件,被 merge 后,这个串就到了文件的中间,不仅没有指示严格模式,反而在压缩后浪费了字节

### JavaScript eval是做什么的?
>eval()函数,这个函数可以把一个字符串当作一个JavaScript表达式一样去执行它
>它的功能是把对应的字符串解析成JS代码并运行
>应该避免使用eval,不安全,耗性能（2次,一次解析成js语句,一次执行）

### javascript的垃圾回收机制（GC）
* 标记清除法：当变量进入执行环境（函数中声明变量）的时候，垃圾回收机制将其标记为‘进入变量’，当变量离开环境的时候（函数执行结束）将其标记为‘离开环境’，在离开环境之后还有的变量则是需要被删除的变量，标记方式不定，可以是某个特殊位的反转或维护一个列表等。
* 引用计数法：该方法容易引起内存泄漏，机制就是跟踪一个值的引用次数，当声明一个变量并将一个引用类型赋值给该变量时该值引用次数加1，当这个变量指向其他一个时该值的引用次数便减一。当该值引用次数为0时就会被回收。

### 浏览器的严格模式与混杂模式
* 浏览器解析时到底使用严格模式还是混杂模式，与网页中的 DTD(Document Type Definition) 直接相关
>1、如果文档包含严格的 DOCTYPE ，那么它一般以严格模式呈现。（严格 DTD ——严格模式）
>2、包含过渡 DTD 和 URI 的 DOCTYPE ，也以严格模式呈现，但有过渡 DTD 而没有 URI （统一资源标识符，就是声明最后的地址）会导致页面以混杂模式呈现。（有 URI 的过渡 DTD ——严格模式；没有 URI 的过渡 DTD ——混杂模式）
>3、DOCTYPE 不存在或形式不正确会导致文档以混杂模式呈现。（DTD不存在或者格式不正确——混杂模式）
>4、HTML5 没有 DTD ，因此也就没有严格模式与混杂模式的区别，HTML5 有相对宽松的语法，实现时，已经尽可能大的实现了向后兼容。（ HTML5 没有严格和混杂之分）

### JavaScript 谈谈 this 对象的理解
>this 指的是调用函数的那个对象
>this 在没有运行之前不能知道代表谁;js的this 指向是不确定的；和定义没有关系，和执行有关
>执行的时候，点前面是谁，this 就是谁；自执行函数里面的this 代表的是 window
>定时器书写的时候，window可以省略掉；定时器执行的时候，里面的this 代表的也是 window
>this 是js的一个关键字，随着函数使用场合不同，this 的值会发生变化

### JavaScript 什么是window对象? 什么是document对象?
>document 是 window 的一个对象属性
>window 对象表示浏览器中打开的窗口
>如果文档包含框架（frame 或 iframe 标签），浏览器会为 HTML 文档创建一个 window 对象，并为每个框架创建一个额外的 window 对象
>所有的全局函数和对象都属于Window 对象的属性和方法
>document 对 Document 对象的只读引用

### JavaScript原型，原型链 ? 有什么特点
* 原型
>在JavaScript中,一共有两种类型的值,原始值和对象值.每个对象都有一个内部属性 prototype,我们通常称之为原型
>原型的值可以是一个对象,也可以是null
>访问一个对象的原型可以使用Object.getPrototypeOf方法,或者`__proto__`属性

* 原型链：原型向上查找的过程属于原型链
* 特点：
>可以向上查找，不能向下查找
>原型链的作用是用来实现继承的

### Javascript中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是?
* javaScript中hasOwnProperty函数方法是返回一个布尔值，指出一个对象是否具有指定名称的属性。object.hasOwnProperty(proName)

### 把 Script 标签 放在页面的最底部的body封闭之前 和封闭之后有什么区别？浏览器会如何解析它们？
* 从实际效果来看，是没有区别的，但是放在 html 结束标签之前应该是不规范的(通不过 HTML 验证)，放在 body 结束之前才对，

### script标签的位置会影响首屏时间么？
* 不影响但有可能截断首屏的内容，使其只显示上面一部分

### cookie字段
* name：字段为一个cookie的名字
* value：字段为一个cookie的值
* domain：字段为可以访问cookie的域名
* path：字段为可以访问此cookie的页面路径
* expires：字段为cookie的超时时间，不设置默认为session
* size：字段为cookie大小
* http：字段cookie的httponly属性，若此属性为true，则只有在http请求头中会带有此cookie的信息，而不能通过document.cookie来访问此cookie
* secure：字段设置是否能通过https来传递此条cookie

### cookie的有效作用域（通过domain来设置作用域的）
* 设置cookie时省略domain参数，那么domain默认为当前域名
* domain可以设置父域名或自身，但不能设置其他域名，包括子域名，否则cookie不起作用

### cookie，localstorage，sessionstorage区别
* 存储大小：cookie4k，storage5M
* 有效期：cookie拥有有效期，sessionstorage会话存储，关闭浏览器消失，localstorage永久存储
* cookie会发送到服务端，存储在内存中，sessionstorage存储在内存，localstorage只存储在浏览器端
* 路径：cookie有路径限制，storage只存储在域名下
* API：cookie没有特定的API，storage有特定的API
* 作用域：不同浏览器无法共享localstorage，sessionstorage，相同浏览器的不同页面间可以共享相同的localstorage，不同页面或标签页间无法共享sessionstorage，

### typeof可以区分哪些类型
* 识别所有值类型
* 识别函数
* 判断是否是引用类型（不可再区分）

### 浏览器事件机制中，事件触发的三个阶段
* 捕获阶段：事件从根节点流向目标节点，途中流经各个DOM节点，在各个节点上触发捕获事件，直到达到目标节点
* 目标阶段：事件到达目标节点时，就到了目标阶段，事件在目标节点上被触发
* 冒泡阶段：事件在目标节点上触发后，不会终止，一层层向上冒，回溯到根节点

### javascript中for of和for in的区别
* 推荐循环对象使用for in，遍历数组使用for of
* for in循环出是key，for of循环出是value
* for of是ES6引入修复了for in的不足
* for of不能遍历普通对象，需要通过和`Object.keys()`（遍历key值），`Object.values()`（遍历value值），`Object.entries()`（key与value同时遍历）搭配使用

### 同步机制有哪些
* 临界区，互斥对象，信号量，事件对象

### 同步与异步的区别
* 异步基于js单线程
* 异步不会阻塞代码的执行，同步会阻塞代码的执行
* 执行顺序：同步 —> 微任务（promise） —> 宏任务（settimeout）
|宏任务|浏览器|Node|
|:-:|:-:|:-:|
|setTimeout|有|有|
|setInterval|有|有|
|setImmediate|无|有|
|requestAnimationFrame|有|无|

|微任务|浏览器|Node|
|:-:|:-:|:-:|
|process.nextTick|无|有|
|MutationObserve|有|无|
|promise|有|有|

### DOM是那种数据结构
* DOM树，树形结构

### attribute和propert的区别
* propert：修改对象属性，不会体现到html结构中
* attribute：修改html属性，会改变html结构
* 两者都可能引起DOM重新渲染，尽量使用propert

### 一次性插入多个DOM，怎样优化
* 可以使用createDocumentFragment进行操作
* 考虑dom节点的缓存，尽可能先获取所有的然后进行缓存，然后通过缓存进行操作，尽可能不边操作边获取dom

### 如何减少DOM操作
* 缓存DOM查询结果
* 多次DOM操作，合并到一次插入


### 编写一个通用的监听函数
```javascript
function bindEvent (elem, type, select, fun) {
  // 判断是否有回调
  if (fun == null) {
    fun = select // 没有回调，fun等于第三个参数
    select = null // 第三个参数为null
  }
  elem.addEventListener(type, event => {
    // 判断是否有第三个参数
    if (select) {
      // 代理绑定，matches：判断一个dom元素是否符合与一个css选择器
      if (event.target.matches(select)) {
        fun.call(elem, event)
      }
    } else {
      // 普通绑定
      fun.call(elem, event)
    }
  })
}

bindEvent(div, 'click', 'button', () => {
  console.log('button')
})
bindEvent(div, 'click', () => {
  console.log('1')
})
```

### 描述冒泡事件流程
* 基于DOM树形结构
* 事件会顺着触发元素向上冒泡
* 应用场景：代理

### 无限下拉的图片列表，如何监听每个图片的点击
* 事件代理
* 用e.target获取触发元素
* 用matches来判断是否触发元素

### 手写ajax
* get

```javascript
const xhr = new XMLHttpRequest()
xhr.open('GET', 'city.json', true)
xhr.onreadystatechange = () => {
  if (xhr.readyState === 4) {
    if (xhr.status === 200) {
      console.log(JSON.parse(xhr.responseText))
    }
  }
}
xhr.send(null)
```

* post：发送内容为字符串而不是json

```javascript
const xhr = new XMLHttpRequest()
// false：同步。true：异步
xhr.open('POST', 'city.json', true)
xhr.onreadystatechange = () => {
  if (xhr.readyState === 4) {
    if (xhr.status === 200) {
      console.log(JSON.parse(xhr.responseText))
    }
  }
}
const data = {
  name: 'byron',
  password: '123'
}
xhr.setRequestHeader("content-type","application/x-www-form-urlencoded")
xhr.send(JSON.stringify(data))
```

* xhr.readyState:
0：未初始化，还没有调用send()方法
1：载入，以调用send()方法，正在发送请求
2：载入完成 send()方法执行完成，已经接收到全部响应内容
3:   交互，正在解析响应内容
4：完成，响应内容解析完成，可以在客户端调用

* xhr.status：http状态码
2xx：表示成功的处理
3xx：需要重定向，浏览器直接跳转，301，302，304
4xx：客户端请求错误，404，403
5xx：服务端错误

### 跨域部分
* 同源策略：ajax请求时，浏览器要求当前网页和server必须同源（安全）同源：协议，域名，端口，三者必须一致
* 加载img，css，js可以无视同源策略，jsonp
* 哪些情况会发生跨域现象：AJAX，cookie，iframe

### 解释 JSONP原理，为何不是真正的ajax
* script 可以绕过浏览器的跨域限制，jsonp只能使用get
* 服务器可以任意动态拼接数据返回
* script 可以获得跨域的数据，只要服务端愿意返回
* script，img标签都可以绕过跨域

```javascript
// 手写简易jsonp
// 第一步创建jsonp.js文件并添加服务（跑起来后假如地址为：http://172.20.10.12:8080）
abc(
  {
    name: 'byron'
  }
)
// 第二步在html文件中使用script调用该jsonp.js的地址（说加载脚本，实则获取数据）（重新跑这个页面，肯定与jsonp.js文件的地址不同，然后就可以进行跨域了）
<!DOCTYPE html>
<html>
<head>
  <title>jsonp</title>
</head>
<body>
<script>
  window.abc = (data) => {
    console.log(data)
  }
</script>
<script type="text/javascript" src="http://172.20.10.12:8080/jsonp.js?user=byron&callback=abc"></script>
</body>
</html>
```

### CORS
* 在后端进行设置，前端可以直接进行访问

```javascript
// 第二个参数填写允许跨域名称，不建议直接写'*'
Response.setHeader('Access-Control-Allow-Origin', 'http://localhost:8081')
Response.setHeader('Access-Control-Allow-Header', 'X-Requested-With')
Response.setHeader('Access-Control-Allow-Methods', 'PUT,POST,GET,DELETE,OPTIONS')
// 接收跨域的cookie
Response.setHeader('Access-Control-Allow-Credentials', 'true')
```

### 描述cookie，localstorage，sessionstorage区别
* cookie：本身用于浏览器和server通讯，被借用到本地来存储，使用document.cookie进行访问赋值，最大存储4kb
* localstorage（永久存储），sessionstorage（会话存储）最大存储5M，不会随着http请求发送吗，setItem，getItem为api

### 经典面试题
```javascript
let test = {
  name: 'test',
  say: function () {
    console.log(this.name) // test
  },
  says: () => {
    console.log(this.name) // undefined
  }
}
test.say()
test.says()
```

### window.onload和DOMContentLoaded的区别
* window.onload：页面全部资源加载完成才会执行，包括图片，视频等
* DOMContentLoaded：DOM渲染完即可执行，此时图片，视频可能还没有加载完

### 防抖（频繁操作，最后进行触发）
* 监听一个输入框，文字变化后触发change事件
* 直接用keyup事件，则会频繁触发change事件
* 防抖：当用户输入结束或暂停时，才会触发change事件

```javascript
// 手写防抖函数
    function debounce(fun, delay = 500) {
      let timer = null
      return function () {
        if (timer) {
          clearTimeout(timer)
        }
        timer = setTimeout(() => {
          fun.apply(this, arguments)
          timer = null
        }, delay)
      }
    }

    input1.addEventListener('keyup',debounce(function () {
      console.log(this.value)
    }, 2000))
```

### 节流（频繁操作，保持一个频率连续触发）
* 拖拽一个元素时，要随时拿到元素被拖拽的位置
* 直接用drag事件，则会实时触发，很容易导致卡顿
* 节流：无论拖拽速度多快，都会每隔100ms触发一次

```javascript
// 手写节流函数
    function throttle(fun, delay = 500) {
      let timer = null
      return function () {
        if (timer) {
          return
        }
        timer = setTimeout(() => {
          fun.apply(this, arguments)
          timer = null
        }, delay)
      }
    }
    div1.addEventListener('drag', throttle(function (e) {
      console.log(e.offsetX, e.offsetY)
    }, 100))
```

### ES5和ES6实现每隔一秒打印一个数字
```javascript
  // ES6
  for (let i = 0; i < arr.length; i++) {
    setTimeout(() => {
        console.log(arr[i])
    }, 1000 * i)
  }
  // ES5
  for (var i = 0; i < arr.length; i++) {
    (function(i){
      setTimeout(function(){
        console.log(arr[i])
      }, 1000 * i)
    })(i)
  }
```

### 函数call和apply的区别
* 传参方式不同，call是依次传递参数，apply是传递一个数组

### 闭包是什么，有何特性，有何影响
* 闭包就是能够访问其他函数作用域中的变量
* 延长了变量的作用范围，加强封装性，可以达到对变量的保护
* 变量会常驻内存，得不到释放，闭包不要乱用

### 函数声明和函数表达式的区别
* 函数声明：function fun () {}
* 函数表达式：const fun = function () {}
* 函数声明会在代码执行前预加载（类似与变量预加载），而函数表达式不会

### new Object()和Object.create()区别
* {}等同于new Object()，原型Object.prototype
* Object.create(null)没有原型
* Object.create({})可以指定原型，且当前变量的`__proto__`等于指定变量

```javascript
const obj1 = {
    a: 10,
    b: 20,
    sum () {
      return this.a + this.b
    }
  }

  const obj2 = new Object({
    a: 10,
    b: 20,
    sum () {
      return this.a + this.b
    }
  })

  // const obj2 = new Object(obj1) // obj1 === obj2  true
  const obj3 = Object.create(null) // {} 没有原型
  const obj4 = new Object() // {} 有原型
  const obj5 = Object.create( { // {} 有原型,且内容在原型中
    a: 10,
    b: 20,
    sum () {
      return this.a + this.b
    }
  })
  const obj6 = Object.create(obj1) // obj6.__proto__ === obj1 true
```

### http方法有哪些
* get/post/put/delete/head/options

### get/post的区别
* 参数：
>get传递参数只能在url后面，文本格式为QueryString
>post可以传递application/x-www-form-urlencoded的类似QueryString、multipart/form-data的二进制报文格式，一般用于文件传输

* 用途：
>get用于从服务器端获取数据，包括静态资源（html/js/css/image等），动态资源（列表数据，详情数据）
>post用于向服务器提交数据，比如增删改数据，提交一个表单或者新建/修改一个用户

* 缓存：
>get默认会复用前面的请求数据作为缓存结果返回，解决方案：可以在url后面添加一个随机参数来进行更新缓存
>post一般不会被缓存因素影响

* 安全性:
>get：明文传输
>post：密文传输，相对来说更安全，但是安全的前提是正确使用二者

### ES6中import和commonJS中require的区别
* import是ES6写法，最终会转换为require，require遵循commonJS模块化解决方案
* ES6模块是编译时输出接口，commonJS模块是运行时加载
* ES6模块是动态引用，即导入和导出的值都指向同一个内存地址，所以导入的值会随着导出值变化。CommonJs的模块是对象。导出时是指拷贝，就算导出的值变化了，导入的值也不会变化，如果想要更新值就要重新导入
* import语句导入同一个模块如果加载多次只执行一次，require语句导入次数和实际执行次数相同
* import必须用在当前模块的顶层，如果在局部作用域内，会报错，es6这样的设计可以提高编译器效率，但没法实现运行时加载。require可以用在代码的任何地方
* import是关键词，require不是关键词
* require支持动态引入，也就是require(${path}/xx.js)，import目前不支持，但是已有提案

### 手写字符串trim写法
```javascript
String.prototype.trim = function() {
    return this.replace(/^\s+/, '').replace(/\s+$/, '')
  }
```

### 如何捕获js中的异常
* try{} catch(e){}
* window.onerror：对跨域的js，如CDN不会有详情信息，对于压缩js还需要配合sourceMap反查为压缩代码的行、列

### 获取url参数
```javascript
function query(name){
    const search = location.search
    const p = new URLSearchParams(search)
    return p.get(name)
  }
  // http://127.0.0.1:5501/jsInterview/32-query.html?b=%27123%27
  console.log(query('b')) // '123'
```

### 手写flag函数
```javascript
function flat(arr) {
    // 判断是否有二维数组
    let isDeep = arr.some(item => item instanceof Array)
    if(!isDeep) {
      return arr
    }
    const res = Array.prototype.concat.apply([], arr)
    return flat(res)
  }

  let arr = [1, [2, [3, [4, [5]]]]]
  console.log(flat(arr))
```

### 手写深度比较（全相等）
```javascript
// 判断是否为object
  function isObj(obj) {
    return typeof obj === 'object' && obj !== null
  }
  // 深度比较（全相等）
  function isEqual(obj1, obj2) {
    // 查看参数是否为obj
    if (!isObj(obj1) && !isObj(obj2)) {
      // 如果都不是object那么就是值类型，一般不会是函数
      return obj1 === obj2
    }
    // 如果传递的是一个对象
    if (obj1 === obj2) {
      return true
    }
    // 判断参数个数
    const obj1keys = Object.keys(obj1)
    const obj2keys = Object.keys(obj2)
    if (obj1keys.length !== obj2keys.length) {
      return false
    }

    for (let key in obj1) {
      const res = isEqual(obj1[key], obj2[key])
      if (!res) {
        return false
      }
    }
    return true
  }
```

### 有以下3个判断数组的方法，分别输出什么
```javascript
let arr = [1, 2, 3]
// Object.prototype.toString.call()
console.log(Object.prototype.toString.call(arr)) // [object Array]
// instanceof 既可以判断父类也可以判断子类
console.log(arr instanceof Array) // trur
// Array.isArray(arr) // 可以用于prototype
console.log(Array.isArray(arr)) // trur
```

### 介绍RAF requestAnimationFrame
* 要想动画流畅，更新频率要60帧/s，即16.67ms更新一次视图
* setTimeout要手动控制频率，而RAF浏览器会自动控制
* 后台标签或隐藏iframe中，RAF会暂停，而setTimeout依然执行

### 手写call
```javascript
function person (a, b, c) {
  console.log(this.name)
  console.log(a, b, c)
}
const egg = {
  name: 'byron'
}

Function.prototype.myCall = function(obj) {
  // 第一步：判断当前obj是否为空，若为空设置为window
  var obj = obj || window;
  // 第二步：对形参添加一个函数指向this也就是调用该方法的函数
  obj.p = this
  // 第三步：设置一个存放除this以外参数的数组
  let newArr = []
  // 第四步：循环arguments，填充newArr
  for (let i = 1; i < arguments.length; i++) {
    // 这里要存储的类型为arguments[1],arguments[2]...
    newArr.push(`arguments[${i}]`)
  }
  // 第五步：使用eval函数解析字符串并执行
  let request = eval(`obj.p(${newArr})`)
  // 第六步：移除绑定
  delete obj.p
  // 返回内容
  return request
}

person.myCall(egg, 'egg', 'tianji', 'gua')
```

### 手写apply
```javascript
Function.prototype.myApply = function (obj, arr) {
  var obj = obj || window;
  let result
  obj.p = this
  
  if (!arr) {
    result = obj.p()
  } else {
    let newArr = []
    for (let i = 0; i < arr.length; i++) {
      newArr.push(`arr[${i}]`)
    }
    result = eval(`obj.p(${newArr})`)
  }

  delete obj.p
  return result
}
```

### 手写bind
```javascript
Function.prototype.myBind = function(obj) {
  // 判断是调取是否为函数
  if (typeof this !== 'function') {
    throw new TypeError('不是function')
  }
  // 保存当前this
  let that = this
  // 获取除arguments[0]的其他参数转换为数组（第一个括号内）
  let arr1 = Array.prototype.slice.call(arguments, 1)
  // 设置一个空函数，用来进行桥接prototype
  let o = function() {}
  // 定义返回方法
  newf =  function () {
    // 获取arguments参数并转换为数组(第二个括号内)
    let arr2 = Array.prototype.slice.call(arguments)
    // 将第一个数组与第二个数组合并
    let arr = [...arr1, ...arr2]
    // 如果new后 this指向空
    if (this instanceof newf) {
      that.myApply(this, arr)
    } else {
      // 反之则指向当前对象
      that.myApply(obj, arr)
    }
  }
  // newf.prototype = that.prototype
  // 设置空函数的原型为调用函数的prototype
  o.prototype = that.prototype
  // 设置返回函数的原型为空函数的原型，这样做的目的是提高性能
  newf.prototype = new o
  // 返回函数
  return newf
}
person.myBind(egg, 'egg', 'tianji', 'gua')('hello')
```

### 手写sleep
```javascript
// 测试函数
  function fn() {
      console.log('测试延迟')
    }
  // 第一种：回调函数
  function sleep(callback, time) {
    if (typeof callback === 'function') {
      setTimeout(callback, time)
    }
  }
  sleep(fn, 3000)


  // 第二种：promise
  function sleep(timer) {
    return new Promise(resolve => setTimeout(resolve, timer))
  }
  sleep(3000).then(() => {
    fn()
  })

  // 第三种：Generator
  function * sleep(timer) {
    yield new Promise(resolve => setTimeout(resolve, timer))
  }
  sleep(3000).next().value.then(value => {
    fn()
  })
```

### async/await原理
* async函数就是generator函数的语法糖，async就是将generator函数的 * 换成了async，将yield换成了await
* async针对generator做了一下改进：
1. 内置执行器，不需要使用next()手动执行
2. await后可以是一个promise对象或者原始类型的值，yield后只能是函数或者promise对象
3. 返回非promise时，async会将返回值包裹为promise

###  js中 0.1+0.2 为什么不等于0.3 怎样解决
* 在JavaScript中的二进制的浮点数0.1和0.2并不是十分精确，在他们相加的结果并非正好等于0.3，而是一个比较接近的数字 0.30000000000000004 ，所以条件判断结果为false
* 解决方法：设置一个误差范围值，Number.EPSILON，这个值正等于2^-52，这时候就可以这样写 (0.1+0.2)-0.3小于Number.EPSILON，在这个误差的范围内就可以判定0.1+0.2===0.3为true。

### 小题
1. 

```javascript
// 数字与字符串进行比较：
// 1：如果是纯数字与数字型字符串比较("999"<1000)，那么字符串会转化为数字，parseInt()
// 2：数字与其他字符串之间比较(222<'abc')，字符串转换为数字，parseInt('abc')，解析不到数字返回一个NAN
// 3：数字型字符串比较("999"<"1000")，比较ASCll码值，依次取每个字符，字符转为ASCll码进行比较，ASCll码先大的即为大
// 4：其他字符串进行比较('d'>'abc')，字符串比较为ASCII码比较
"999" < 1000 //true
999 < "1000" //true
"999" < "1000" // false
"999" == 999 //true
"999" === 999 //false

console.log([1,2,3,4,5].splice(1,2,3,4,5)) // [2,3]
console.log([1,2,3,4,5].slice(1,2,3,4,5)) // [2]

var bar = [1,2,3]
for(var i in bar) {
  setTimeout(() => {
    console.log(bar[i]) // 3 3 3
  },0)
  console.log(bar[i]) // 1 2 3
}

Object.prototype.foo = 'Object'
Function.prototype.foo = 'Function'
function Animal() {}
var cat = new Animal()
console.log(cat.foo) // Object
console.log(Animal.foo) // Function
```
2. 倒计时一般都会放在后端进行处理，前端一般是防不住的
3. 用户登录状态存放在localStorage，cookie中
4. 网页一键换肤方法：替换类名方法，样式表方法，参数请求（url传参给后端，后端根据参数判断返回对应的html 服务端渲染）
5. 有时候会碰到这样的问题，存放图片的盒子要比图片本身大，前提是图片是100%宽或高，遇到这样的问题就把img变为块级元素，完美解决，因为img是文本类型inline-block，所以img总会有一点文本的高度




## 运行环境
### git
### 调试工具
### 抓包工具
### webpack babel
### linux基本命令

### 网页加载过程
#### 从输入url到渲染页面的整个过程
* DNS解析：域名 -> ip地址

* 浏览器根据ip地址向服务器发起http请求

* 服务器处理http请求，并返回给浏览器

* 根据HTML代码生成DOM Tree

* 根据css代码生成CSSOM

* 根据DOM Tree和CSSOM整合形成Render Tree

* 根据Render Tree渲染页面

* 遇到script后分三种：
  1.未设置async，defer，浏览器继续加载js，并阻塞，等待js加载并执行完成，然后继续解析文档。
  2.设置async，异步加载脚本，脚本加载完立即执行脚本。（如果有多个async，谁先加载完谁先执行）
  3.设置defer，异步加载脚本，文档解析完成后，DOMContentLoaded事件调用前执行脚本，（如果有多个defer则按顺序进行加载，当所有defer加载完成后，按顺序执行脚本，即使前面脚本有延迟）

* 文档解析完成，此时document.readyState = 'interactive'

* 设置defer的js脚本执行

* document触发DOMContentLoaded事件，标志着程序执行由同步脚本阶段转换为事件驱动阶段

* 文档和所有资源加载完成，document.readyState = 'complete'，window触发onload事件

* 直至把Render Tree渲染完成

### 性能优化
* 多使用内存，缓存其他方法，（图片懒加载）
* 减少cpu计算量，减少网络加载耗时
* 加载更快
>减少资源体积，压缩代码
>减少访问次数，合并代码，ssr服务器端渲染，缓存
>使用更快的网络：CDN

* 渲染更快
>css放在header，js放在body最下面
>懒加载
>尽早开始执行js，用DOMContentLoaded触发
>对DOM查询进行缓存
>频繁DOM操作，合并到一起插入到DOM结构
>节流throttle	防抖debounce

### 常见的web前端攻击方式有哪些
* XSS跨转请求攻击

```shell
#模拟场景
#1:一个博客网站，我发表一篇博客并嵌入<script>脚本
#2:脚本内容：获取cookie，发送到我的服务器，我的服务器配合跨域
#3:发布这篇博客后，有人查看他，从而我获取到访问者的cookie
#预防XSS，可以使用npm的xss包来做这些事情
#1:替换特殊字符，如<变为&lt; >变为&gt;
#2:<script>变为&lt;script&gt;，直接显示，而不会被作为脚本运行
#3:前后端都需要做替换
```

* CSRF/XSRF跨站请求伪造

```shell
#模拟场景
#1:你正在购物，看中了某个商品，商品id是100
#2:付费接口是xxx.com/pay?id=100, 但是没有验证
#3:我是攻击者，我看中一个商品，id是200
#4:我向你发送一封电子邮件
#5:邮件正文隐藏这<img src=xxx.com/pay?id=200 />
#6:你一查看邮件，就帮我购买了id为200的商品
#预防XSRF
#1:使用POST接口
#2:增加验证，例如密码，短信验证，指纹，人脸识别
```


## 计算机网络部分
### 七层协议
* 物理层												 信息格式：帧/比特流
* 数据链路层	mac地址							 信息格式：帧/比特流
* 网络层	ip、ARP、ICMP						  信息格式：ip数据报
* 传输层	TCP、UDP、 TLS加密				信息格式：分组
* 会话层													信息格式：报文流
* 表现层													信息格式：报文流
* 应用层	http POP3									信息格式：报文流

### 当用户输入网址后发生了什么
* 协议、主机、端口、路径
* 当输入地址后，浏览器会先查到缓存（浏览器/系统/路由/web服务缓存），如果有缓存，那么就会直接在缓存中进行读取，不会调取服务器的数据，如果没有缓存，那么就要去服务器中获取数据，（DNS解析 ）通过域名解析出ip，ip对应的一台服务器，找到服务器后，浏览器要与web服务建立连接，建立连接通过后，浏览器就会向服务器发送请求，服务器需要安装web服务，否则无法建立连接，然后进行TCP三次握手，握手通过后，web服务会给浏览器发送一个页面标签地址内容，浏览器拿到后进行渲染，首先先根据html标签绘制一个dom树，css会生成一个cssdom树，最后生成render树，然后从上到下依次进行执行，如果是外部连接会同时发送并列请求
* 详细版：
>1、浏览器会开启一个线程来处理这个请求，对URL 分析判断如果是http协议就按照Web方式来处理
>2、调用浏览器内核中对应的方法，比如WebView中的loadUrl方法
>3、通过DNS解析获取网址的ip地址，设置UA等信息发出第二个GET请求
>4、进行HTTP协议会话，客户端发送报头（请求报头）
>5、进入到web服务器上的WebServer,如Apache，Tomcat，Nodejs，Nginx等服务器
>6、进入部署好的后端应用，如PHP、java、JavaScript、python等，找到对用的请求处理、
>7、处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回会304

### http与https的区别
* http不安全，默认端口为80，https安全，默认端口为443
* http在osi网络模型的最高层应用层，https有安全机制在传输层完成
* 七层模型：（物数网传会表应）
* http直接发布即可，https需要申请SSL证书

### 什么是http无状态协议，以及怎样解决
* 无状态协议：没有记忆功能，一次http请求结束后就结束了，没有记忆能力，第二次请求取不回上次的数据
* 解决方案：session，cookie，html5新特性本地存储

### http工作原理
1.浏览器将自己支持的一套加密规则发送给网站。
2.网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。
3.浏览器获得网站证书之后浏览器要做以下工作：
a) 验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。
b) 如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密。
c) 使用约定好的HASH算法计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。
4.网站接收浏览器发来的数据之后要做以下的操作：
a) 使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。
b) 使用密码加密一段握手消息，发送给浏览器。
5.浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。

![](http://ww3.sinaimg.cn/large/7cc829d3gw1f7xujtsfmhj20bu0cuq3k.jpg)

### http有哪些状态码
* 100：Continue继续。客户端应继续其请求，
* 101：切换协议
* 200：正常，请求成功
* 201：已创建。成功请求并创建了新的资源
* 202：已接受。已经接受请求，但未处理完成
* 203：非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本
* 204： 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档
* 205：重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域
* 206：部分内容。服务器成功处理了部分GET请求
* 301：永久重定向
* 302：临时重定向
* 303：查看其它地址。与301类似。使用GET和POST请求查看
* 304：服务端资源与客服端资源上次请求一致，不需要重新传输，客户端使用本地缓存的即可
* 305：使用代理，所请求的资源必须通过代理访问
* 306：已经被废弃的HTTP状态码
* 307：临时重定向。与302类似。使用GET请求重定向
* 400：客户端请求的语法错误，服务器无法理解
* 401：请求要求用户的身份认证
* 402： 保留，将来使用
* 403：禁止被访问
* 404：找不见资源
* 405：客户端请求中的方法被禁止
* 406：服务器无法根据客户端请求的内容特性完成请求
* 407：请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权
* 500：服务器内部错误
* 502：网关错误，已经与后端建立连接，但超时
* 503：服务器超载或无法处理请求
* 504：与后端未建立连接，超时

### 常用的http的header字段
* Accept：设置接收的内容类型
* Accept-Charset：设置接收的字符编码
* Expires：设置响应体过期事件
* Content-Type：设置响应体的MIME类型
* Date：设置响应体的过期时间
* Set-Cookie：设置HTTP Cookie
* Status：设置HTTP响应状态

### 什么是TCP协议
* 特点：面向连接（收发数据前，必须建立可靠的连接）
* 建立连接基础：三次握手
* 应用场景：数据必须准确无误的手法，HTTP请求，FTP文件传输，邮件收发
* 优点：稳定，重传机制，拥塞控制机制，断开连接
* 缺点：速度慢，效率低，占用资源，容易被攻击（三次握手 -> DOS, DDOS攻击）
* TCP/IP协议组：提供点对点的连接机制，制定了数据封装、定指、传输、路由、数据接收的标准

### 什么是UDP协议
* 特点：面向无连接（不可靠的协议，无状态传输机制）
* 无连接信息发送机制
* 应用场景：无需确保通讯质量且要求速度快、无需确保信息完整
* 消息收发、语音通话。、直播（qq）
* 优点：安全、快速、漏洞少（UDPflood攻击）
* 缺点：不可靠、不稳定、容易丢包
* 只要目的源地址、端口号、地址、端口号确定、则可以直接发送信息报文，但不能保证一定能收到或收到完整的数据

### TCP与UDP的区别
* 基于连接与无连接；
* 对系统资源的要求（TCP较多，UDP少）
* UDP程序结构较简单
* 流模式与数据报模式
* TCP保证数据正确性，UDP可能丢包
* TCP保证数据顺序，UDP不保证

### 三次握手（建立连接）
* 第一步：客户端向服务端发送syn（同步序列编号）包（序号是j），进入到SYN_SEND状态（等待服务器确认状态）
* 第二步：服务端接收到客户端的syn j后，向客户端发送syn（序号是k）+ack（序号是j+1）（确认字符）包，服务器进入SYN_RECV（请求接收并等待客户端确认状态）
* 第三步：客户端向服务端发送ack包（序号为k+1），服务端收到ack标识位后，完成三次握手，成功建立连接

### 四次挥手（断开连接）
* 第一步：客户端向服务端发送FIN需要断开连接
* 第二步：服务端基于可靠性向客户端发送FIN+ACK
* 第三步：服务端向客户端发送FIN需要断开连接
* 第四步：客户端向服务端发送ACK，然后资源销毁

### 当一个服务端对应多个客户端为什么不会发错数据
* 是因为socket的四元组即ip+port ip+port，四个只要有一个不同就能够进行区分

### http1.0与http1.1与http2.0区别
* 1.0：短连接（100张图，100次tcp握手和挥手）
* 1.1：长连接（100张图，1次tcp握手挥手）
* 2.0：长连接+io多路复用模型

### HTTP与HTTPS区别
* https相对于http增加了一层安全层（SSL/TLS）安全嵌套层，传输层安全，为网络通信提供安全及数据完整性的一种安全协议，对网络连接进行加密
* http是不安全的（监听和中间人攻击等手段，获取网站账户信息和敏感信息）https可防止被攻击
* http协议的传输内容都是明文的，直接在tcp连接上运行，客户端和服务端都无法验证对方的身份
* https协议的传输内容都是被SSL/TLS加密的，且都运行在SSL/TLS上，SSL/TLS运行在tcp连接上，所以数据传输是安全的

### rpc和http的区别
* 性能：rpc通过thrift二进制传输，http通过json序列化更消耗性能
* 传输协议：rcp基于tcp也可以基于http，http只能是http协议
* 负载均衡：rpc自带负载均衡，http需要自己配置（nginx）
* 传输效率：rpc可以自定义tcp协议，报文相对较小，http有很多无用的东西（很多头部信息）
* 通知：rpc自行通知，http事先通知，自行修改nginx配置或者其他负载均衡的配置

### IP
* ipv4：分配给用户上网实用的互联网协议，十进制
* ipv6：地址空间更大（8组，128位）十六进制，路由表更小，组播支持以及对流支持增强，对自动配置的支持，更高的安全性

### 字节流和字符流的区别
* 编码方式不同决定了处理文件类型不同，字节流（ASCLL）处理二进制文件，字符流（Unicode）处理文本文件

### https加密原理
* 采用加密、数字证书、数字签名的技术来实现

#### 加密算法
* 对称加密：客户端与服务端公用一个密钥来对消息加密，客户端与服务端约定好一个加密的密钥，客户端发消息前用该密钥对消息加密，发送给服务端，然后服务端用该密钥解密拿到信息
>优点：对称加密解决了http中消息保密性问题
>缺点：因为同用一个密钥，使得密钥很容易泄露，难以保证消息来源的可靠性，完整性，准确性

* 非对称加密：客户端与服务端均有一个公钥和私钥，使用公钥加密，需要使用对用的私钥进行解密，相反也是，当客户端发送消息时，先使用服务端公钥加密，服务端接收后使用自己的私钥进行解密
>优点：解决了http中消息保密的问题，使私钥泄露的风险降低，因为公钥加密的消息只有对应的私钥才能解开，所以大大程度上保证了消息的来源性以及消息的准确性，完整性
>缺点：非对称加密需要使用到接收方的公钥对消息进行加密，但是公钥不是保密的，任何人都可以获取，中间人也可以获取。那么中间人就可以做两件事，第一件：可以在客户端与服务端交换公钥时，将客户端的公钥替换为自己的，这样服务端拿到的公钥就不是客户端的，而是中间人的，服务端也无法判断公钥来源的正确性，第二件：中间人可以不替换公钥，但是可以截取客户端发送的信息，修改信息，然后用服务端的公钥加密发往服务器上，从而服务端接收到错的消息。非对称加密的性能要比对称加密的性能慢几倍至上百倍，比较消耗资源，正因如此，https将两种加密结合起来

### http的缓存有哪几种
* 强制缓存：客户端与服务器协商，在一定时间内的请求只有一次调取接口，其他请求则读取缓存
* 协商缓存（弱缓存）：通过获取文件的状态来拿到文件的最后修改时间，也就是ctime我们把这个时间通过响应头Last-Modified来告诉客户端，客户端下次请求的时候会通过请求头if-Modified-Since把这个值带给服务端，只要判断两个值是否相等，相等的304，反之调取接口
* 通过文件内容缓存：将文件读取并进行hash加密做对比，十分消耗性能

### 进程与线程
* 一个程序至少有一个进程，一个进程至少有一个线程
* 内存对资源分配的最小单位是进程，而进程执行的最小单位是线程
* 线程是不能够脱离进程而独立运行的
* 当进程运行时只产生一个线程时，被称为单线程，否则被称为多线程
* 单线程与多线程都是指的在同一进程当中的单或多
* 线程越多意味着你在一个进程中同时执行的任务也就越多

### 二叉树、满二叉树与完全二叉树
* 二叉树：除了叶子结点外，每个结点只有两个分支，左子树和右子树，每个结点最大度数为2
* 满二叉树：除了叶结点外的每一个结点都有左右子结点且叶结点都处于二叉树的最底层
* 完全二叉树：只有最下面的两层结点度小于2，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树

### 链表与数组的区别
* 数组必须事先固定长度，不能适应数据动态的增减，当数据增加时可能超出原先定义的元素个数，当数据减少时，造成内存浪费
* 链表动态的进行存储分配，可以适应数据动态的增减情况，且可以方便的插入，删除数据项




## Vue面试题
### v-show与v-if的区别
* v-show通过css display控制显示和隐藏
* v-if组件真正的渲染和销毁，而不是显示和隐藏
* 频繁切换显示状态用v-show，否则使用v-if

### 为什么v-for中用key
* 必须使用key，且不能使用index和random
* diff算法中通过tag和key来判断，是否是`sameNode`
* 减少渲染次数，提升渲染性能

### computed有何特点
* 缓存，data不变不会重新计算
* 提高性能

### 如何将所有的props传递给子组件
* 使用$props
```javascript
<user v-bind='$props' />
```

### vue的生命周期
* beforeCreate：创建之前，初始化vue示例，data和methods中的数据都未初始化
* created：创建完成后 // 初始化实例，并没有开始渲染，data和methods初始化完成
* beforeMount：挂载之前，vue中的指令执行最终生成编译好的字符串模寄存在虚拟dom中，并没有真正生成到页面上
* mounted：挂载完了 // 页面绘制完成，一般在该函数下获取网络数据，将虚拟dom挂载到页面上
* beforeUpdate：更新之前
* updated：更新完了
* beforeDestroy：销毁之前 // 解除自定义事件event.$off，清除定时器，解除绑定的DOM事件（scroll等）
* destroyed：销毁完了
#### 父子组件间生命周期执行顺序
* 创建与挂载
>父组件：create
>子组件：create
>子组件：mounted
>父组件：mounted

* 更新前与更新
>父组件：beforeUpdate
>子组件：beforeUpdate
>子组件：updated
>父组件：updated

* 销毁前与销毁
>父组件：beforeDestroy
>子组件：beforeDestroy
>子组件：destroyed
>父组件：destoryed

### 如何理解MVVM
数据驱动视图： vue（MVVM），react（setState）
传统组件，只是静态渲染，更新还需要依赖操作DOM

### vue组件如何通讯
* 父到子：props
* 子到父：$emit
* 兄弟组件：bus总线，event.$on,event.$off,event.$emit
* vuex

### 为什么组件data必须是一个函数
* vue编译完成后实际上是一个class，当使用该组件时在进行实例化，实例化后data是唯一的
* 当使用组件时候，执行data，如果data不是一个函数的化，那么每一个组件的data都共享了

### 多个组件有相同的逻辑，如何抽离
* 使用mixin

### 何时使用异步组件
* 加载大组件
* 路由异步加载

### 何时使用keep-alive
* 缓存组件，不需要重复渲染
* 多个静态tab页面切换
* 优化性能

### 何时使用beforeDestroy
* 解绑自定义事件 event.$off
* 清除定时器
* 解绑自定义DOM事件，如window scroll

### 描述组件渲染的更新过程，模板编译
* 编写template模板，然后通过某种方式（比如：vue-template-compiler）生成render函数（with函数），然后执行render函数生成vnode，然后再通过patch函数（diff算法对比新旧dom）渲染到页面，可以使用webpack vue-loader会在开发环境下编译模板，如果不适用的化会在浏览器渲染时进行编译代码，影响性能。
* vue组件可以使用render代替template
* 初次渲染过程：
1、解析模板为render函数（或在开发环境已完成，vue-loader）
2、触发响应式，监听data属性getter setter
3、执行render函数，生成vnode，path(elem，vnode)
* 更新过程
1、修改data，触发setter（此前getter已被监听）
2、重新执行render函数，生成newVnode
3、path(vnode，newVnode)
* 异步渲染（$nextTick）：汇总data的修改，一次性更新视图，减少DOM操作次数，提高性能

### 双向绑定v-model的实现原理，响应式
* input元素的value = this.name
* 绑定input事件this.name = $event.target.value
* data更新触发render
* 核心API：Object.defineProperty（vue3.0启用Proxy）
* Object.defineProperty缺点1：对原始数据进行克隆，需要分别给对象中的每一个属性设置监听
* Object.defineProperty缺点2：深度监听，需要递归到底，以此因计算量大
* Object.defineProperty缺点3：无法监听新增与删除属性，所以有了Vue.set,Vue.delete

### vue如何监听数组变化
* Object.defineProperty不能监听数组的变化，因为Object.defineProperty是对象方法
* 重新定义原型，重写push，pop等方法，实现监听
* Proxy可以原生支持监听数组的变化

### vdom与diff算法，vdom
#### vdom
* vdom：用js模拟DOM结构，计算出最小的变更，操作DOM
* js模拟dom结构为VNode

```javascript
// 模板
<div id='div1' class="container">
  <p>vdom</p>
  <ul style="font-size: 20px;">
    <li>a</li>
  </ul>
</div>
// VNode描述
{
    tag: 'div',
    props： {
      id: 'div1',
      className: 'container'
    },
    children: [{
      tag: 'p',
      children: 'vdom'
    },{
      tag: 'ul',
      props: {
        style: 'font-size: 20px'
      },
      children: [{
        tag: 'li',
        children: 'a'
      }]
    }]
  }
```

#### diff算法
* 只比较同一层，不跨级比较
* tag不相同，则直接删掉重建，不再深度比较
* tag和key两者都相同，则认为是相同节点，不再深度比较

### vue路由
* hash路由：
>hash变化会触发页面跳转，即浏览器的前进，后退
>hash变化不会刷新页面，SPA（单页面）必需的特点
>hash永远不会提交到server端（前端自生自灭）
>一般用于toB的系统，简单易用，对url不敏感

```javascript
// 手写hash
// hash 变化，包括：
    // a. JS 修改 url
    // b. 手动修改 url 的 hash
    // c. 浏览器前进、后退
    window.onhashchange = (event) => {
      console.log(`old url:${event.oldURL}`)
      console.log(`new url:${event.newURL}`)
      console.log(`hash:${location.hash}`)
      console.log(event)
    }

    document,addEventListener('DOMContentLoaded', () => {
      console.log(`hash:${location.hash}`)
    })
    btn1.addEventListener('click', () => {
      location.href = '#/user'
    })
```

* history路由（需要后端的支持）
>用url规范的路由，但跳转时不刷新页面
>toC的系统可以考虑使用，但需要服务端的支持

```javascript
// 手写history
// 页面初次加载，获取path
  document.addEventListener('DOMContentLoaded', () => {
    console.log(`load:${location.pathname}`)
  })

  // 打开一个新的路由
  // 注意哦 用pushState方式，浏览器不会刷新页面
  btn1.addEventListener('click', () => {
    const state = { name: 'page1' }
    console.log('切换路由到page1')
    history.pushState(state, '', 'page1')
  })

  // 监听浏览器的前进 后退
  window.onpopstate = (event) => {
    console.log(event)
    console.log(`onpopstate`, event.state, location.pathname)
  }
```

### vue中Object.defineProperty 为什么不能检测数组的改变
* 新增数据由于属性名（索引）增加而无法被Object.defineProperty所检测到
* 在存储栈区的只有一个指向堆区的指针，数据的改变不会引起指向其指针的变化

### vue常见的性能优化
* 合理使用v-show和v-if
* 合理使用computed
* v-for中添加key，避免与v-if的同时使用
* 自定义事件，DOM事件及时销毁
* 合理使用异步组件
* 合理使用keep-alive
* data层级尽量不要太深
* 使用vue-loader在开发环境做模板编译（预编译）
* 使用ssr
* 懒加载等等

### 路由权限
1. uid -> 后端API -> 路由权限API
2. 后端 -> 用户对应路由权限列表 -> 前端 -> JSON
3. JSON -> 树形结构化
4. 树形结构化的数据 -> vue路由结构
5. 路由结构动态 -> 静态路由
6. 树形结构化的数据 -> 菜单组件

### vue中scoped的原理
* 当使用scoped后：
1. 给DOM节点加一个不重复属性 data-v-5db9451a 标志唯一性
2. 使每个样式选择器后添加类似于"不重复属性"的字段, 类似于作用域的作用,不影响全局
3. 如果组件内部还有组件,只会给最外层的组件里的标签加上唯一属性字段,不影响组件内部引用的组件
4. 父组件无scoped属性,子组件带有scoped,父组件是无法操作子组件的
5. 父组件有scoped属性,子组件无scoped.父组件也无法设置子组件样式.因为父组件的所有标签都会带有data-v-5db9451a唯一标志，但子组件不会带有这个唯一标志属性
6. 父子组建都有，同理也无法设置样式，更改起来增加代码量

### vue3升级内容
* 全部使用ts重写（响应式，vdom，模板编译）
* 性能提升，代码量减少
* 会调整部分API
* Proxy实现响应式，深度监听，性能更好，可监听新增/删除属性，可监听数组变化


## React面试题
### react的生命周期
* constructor()：初始化阶段
* static getDerivedStateFromProps(nextProps, prevState)：从props获取state，该函数必须有返回值，当出现变化时可以返回一个对象来更新state，如果返回null则不更新state
* shouldComponentUpdate(nextProps, nextState)：判断组件是否受state或props更改的影响，默认行为是state每次发生变化组件都会重新渲染，一般用来做优化，可以用PureComponent替代
* render()
* getSnapshotBeforeUpdate()：在最近一次渲染输出（提交到 DOM 节点）之前调用，它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。此生命周期的任何返回值将作为参数传递给 componentDidUpdate()
* componentDidMount()：UI渲染完成，组件挂载后（插入 DOM 树中）立即调用，获取网络数据，实例化请求
* componentDidUpdate(prevProps, prevState, snapshot)：更新后会被立即调用。首次渲染不会执行此方法
* componentWillUnmount()：组件卸载及销毁之前直接调用

### react组件如何通信
* 父 -> 子组件使用props
* 子 -> 父组件自定义事件
* Redux和Context（顶层组件向下传递）

### jsx本质是什么
* jsx可以理解为vue的template模板，但不是模板，本身是js的语法糖
* jsx会通过react.createElement即h函数，返回vnode，第一个参数可能是组件也可能是html tag
* vnode通过path(elem，vnode)，path(vnode， newVnode)渲染和更新到页面中

### context是什么，有和用途
* 可以获取父级传递的内容，从而不用props一层一层向下传递

```javascript
// 父组件
import React, { Fragment } from 'react';
import ProtalsDemo from './ProtalsDemo';

// React.createContext：创建一个上下文的容器(组件)
export const { Provider,Consumer } = React.createContext() 
const BaseUser = () => {
  return (
  	{value：定义传递内容}
    <Provider value='上下文'>
        <ProtalsDemo children='Protals' />
    </Provider>
  )
}
export default BaseUser

// 子组件
import React from 'react'
import ReactDOM from 'react-dom'
// 调用父级的Consumer进行使用父级传递的值
import { Consumer } from './index'

class ProtalsDemo extends React.Component {
    constructor(props) {
        super(props)
    }
    render() {
        return (
          <div className="modal">
            <Consumer>
              {value => <p>{value}</p>}
            </Consumer>
          </div>
        ) 
    }
}
export default ProtalsDemo
```

### shouldComponentUpdate（scu）的用途
* React默认父组件有更新，子组件无条件更新
* SCU不一定每次都要使用
* 必须配合不可变值一起使用

### 描述redux单项数据流
* 组件通过dispatch发送action给store，store调用传入reducer中，reducer进行数据的更新然后返回给store一个新的store，然后store保存更新数据，view调用store数据

### 什么是纯函数
* 返回一个新值，没有副作用，输入数组返回数组，输入对象返回对象
* 不可变值

### 渲染列表，为何使用key
* 与vue类似，必须使用key且不能是index和random
* diff算法中通过tag和key来判断，是否是`sameNode`
* 减少渲染次数，提升渲染性能

### react中setState为何使用不可变值
* 之所以使用不可变值是因为在shouldMountUpdate生命周期中会将改变的值与之前的值做对比来确定是否改变视图，以这种方式优化性能。

### setState是同步还是异步
* 不可变值
* 可能是异步更新，正常使用是异步更新，但是在定时器和自定义的DOM事件上是同步更新
* 可能会合并，当连续的赋值对象时候，会进行合并，当连续的函数调用不会合并
* setState其实无所谓异步还是同步的，主要是看isBatchingUpdates是否为true，如果为true则是异步，如果为false则为同步，isBatchingUpdates在setState执行前设置为true，执行后设置为false

### React的合成事件机制
* 所有事件挂载到document上
* event不是原生的，是SyntheticEvent合成事件对象
* 和vue事件不同，和DOM事件也不同
* 为什么要合成事件机制：更好的兼容行和跨平台；挂载document，减少内存消耗，避免频繁解绑；方便事件的统一管理（比如事务机制）

### batchUpdate机制
* 如果命中batchUpdate机制的化为异步，反之为同步，react再执行函数时提前会默认设置一个 isBatchingUpdates = true，然后开始执行目标函数，函数执行完成后设置 isBatchingUpdates = false。也就是说当存在异步时比如setTimeout，先将isBatchingUpdates = true，然后执行函数中的setTimeout放入宏队列，然后将isBatchingUpdates = false后才会执行宏队列中的setTimeout，所以setTimeout不能命中batchUpdate机制

#### 那些能够命中batchUpdate机制
* 生命周期（以及调用的函数）
* React中注册的事件
* React可以管理的入口

#### 那些不能够命中batchUpdate机制
* setTimeout，setInterval等
* 自定义DOM事件
* React管不到的入口

### React组件渲染和更新过程
#### 渲染
* 生成数据结构（props，state）
* render()生成vnode
* path(elem, vnode)

#### 更新
* setState(newState) ---dirtyComponents（可能有子组件）
* render() 生成newVnode
* path(vnode，newVnode)

### react和vue的区别
####  共同点
* 都支持组件化
* 都是数据驱动视图
* 都使用vdom操作DOM
#### 不同点
* React使用JSX拥抱js，Vue使用模板拥抱html
* React函数式编程，Vue声明式编程
* React更多的需要自力更生，Vue把想要的都给开发者（eg：循环react使用map，vue使用v-for）

### React Hooks与生命周期的关系
* Hooks组件，即使用了Hooks的函数组件，有生命周期
|class组件|Hooks组件|
|-|-|
|constructor|useState|
|getDerivedStateFromProps|useState里面update函数|
|shouldComponentUpdate|useMemo|
|render|函数本身|
|componentDidMount|useEffect，useEffect(fn, [])|
|componentDidUpdate|useEffect|
|componentWillUnmount|useEffect|

### useMemo和useCallback的区别 及使用场景
* 相同点：useMemo和useCallback接收参数都一样的，第一个参数为回调，第二个参数为要依赖的数据，当依赖数据发生变化后才会重新计算结果，也就是起到缓存的作用
* 不同点：useMemo计算结果return回来的值，主要用于缓存计算结果的值，应用场景：计算的状态；useCallback主要用于缓存函数，应用场景如: 需要缓存的函数，因为函数式组件每次任何一个 state 的变化 整个组件 都会被重新刷新，一些函数是没有必要被重新刷新的，此时就应该缓存起来，提高性能，和减少资源浪费

### React中`<Link>`与a标签有什么区别
* link应用范围更广，不会刷新页面，
* a：刷新页面


## DIff算法
### snabbdom-diff算法整理
* 第一步：h函数：输入‘标签’，‘data’，‘子元素’，输出VNode函数，通过VNode函数产生vdom（js对象）
* 第二步：init函数返回path函数。path函数可能有三种情况：

```javascript
patch(Element, VNode)
patch(VNode, NewVNode)
patch(NewVNode, null)
```
patch函数判断第一个参数不是VNode，创建一个空的VNode关联到DOM元素中（也就是挂载/更新到该dom元素上），如果两个参数相同的VNode（通过sameVnode方法（key，tag）进行比较，一般非循环是不设置key的，也就是undefined === undefined）执行patchVnode函数，如果不相同直接删掉重建（也就是sel（tag/标签）不同）

```javascript
function sameVnode (vnode1: VNode, vnode2: VNode): boolean {
  return vnode1.key === vnode2.key && vnode1.sel === vnode2.sel
}
```

* 第三步：patchVnode函数：
>先执行prepatch Hook（类似于钩子函数）
>设置elem，将旧的elem设置为新的elem，否则新的vnode不知道挂载到哪里
>获取旧的children和新的children，如果新旧vnode相同则直接return
>判断vnode.text === undefined，也就是vnode.children !== undefined，一般来说标签内有text就不会有children，如果成立，证明新节点有children
>>判断两者都有children，若成立执行**updateChildren**函数
>>如果新节点有children，旧节点无children，那么旧节点可能有text，若有text，调用`setTextContent`清空text，调用`addVnodes`函数添加children
>>如果旧节点有children，新节点无children，那么调用`removeVnodes`函数旧children
>>如果旧节点text有，新节点text无，那么调用`setTextContent`函数清空text

>判断vnode.text !== undefined，也就是vnode.children === undefined 且 oldVnode.text !== vnode.text成立，若旧节点存在children，调取`removeVnodes`函数移除旧的children，调取`setTextContent`函数添加text

* 第四步：updateChildren函数
>获取oldStartIdx，oldEndIdx，newStartIdx，newEndIdx，（旧children的首位和末尾，新children的首位和末尾）
>进行循环操作，当首尾重叠停止循环
>判断新旧节点的 开始和开始，结束和结束，开始和结束，结束和开始，四个条件如果命中任意一个则执行**patchVnode**函数（通过key和sel进行判断）
>如果以上都未命中，则拿新节点的key能否对应上旧children中的某个节点的key	
>>若没有对应上，证明旧children不存在该节点，则将该节点插入即可
>>若有对应上，获取对应key的节点，判断sel（tag/标签）是否相同
>>>若sel不相同，将该节点插入即可
>>>若sel相同，key相同，指向**patchVnode**函数

* 第五步：虚拟dom生成真实dom，当以上函数都调取完成后，最后返回到patch函数中，patch函数拿到了更新后的虚拟dom
>如果旧节点为空，直接拿到elem，若不为空，获取旧节点的父级节点
>判断tag是否为string，如果是string，证明是一个标签，创建这个标签，判断data属性，循环data，若key为style，再此循环style将style[key] = style[value] 挂载到elem上，若key是class则使用elem.className = class，否则使用setAttribute(key, value) 对tag的属性赋值，判断children，遍历children，创建children递归当前函数不断往下获取子元素，直到获取完成
>如果tag不是string，则是文本节点，创建这个文本
>最后使用insertBefore(新节点，旧节点的下一个节点)（意思就是将新节点插入到旧节点的下一个节点之前，为什么，因为旧节点后可能为script标签，尽可能将新节点插入到script标签之前，浏览器执行script标签会中断所以要插入到script之前），然后删除旧节点，完成虚拟dom到真实dom的转换。

### vue和react的diff算法区别
* vue对比节点，当节点元素类型相同，但是className不同，认为是不同类型的元素，删除重建，而react会认为是同类型节点，只是修改节点属性
* vue的列表对比，采用从两端到中间的对比方式，react采用从左到右依次比较的方式，当一个集合，只是把最后一个节点移动到第一个，react会把前面的节点依次移动，vue只会把最后一个节点移动到第一个。





## Webpack面试题
### 前端代码为何要进行构建和打包
### module chunk bundle分别是什么意思，有何区别
### loader和plugin的区别
* loader是文件加载器，能够加载资源文件，并对这些文件进行一些处理，如编译，压缩，最终打包到指定的文件中
* 在webpack广播中会出现许多事件，plugin会监听这些事件，在合适的时机通过webpack提供的api改变输出结果

### webpack如何实现懒加载
### webpack常见的性能优化
### babel-runtime和babel-polyfill的区别

## Node面试题
### 介绍一下npm模块安装机制，为什么输入npm install 就可以自动安装对应的模块
* 当实用npm安装模块时会把依赖信息安装到package.json中，当使用npm install后自动到package.json上找到依赖项进行安装模块


## 发散问题
### 为什么使用框架
* 代码模块化
* 框架封装了常用的基础操作，高内聚
* 规范性
* 可扩展性
* 可维护性
* 协作开发
* 通用性

### 框架解决了哪些问题
* 重复引用外部js
* 组件化
* 开发周期长
* 性能：框架和jQuery虽然都会操作DOM，但是框架吧大量的DOM进行了处理和优化（例如Vue的虚拟DOM），通过数据驱动，就能渲染出DOM，大大提升了性能

### 什么是面向过程
* 是一种以过程为中心的编程思想，这些都是以什么正在发生为主要的目标进行编程的，不同于面向对象的是谁在受影响
* 优点：效率高
* 不宜维护，不宜复用，不易扩展

### 什么是面向对象
* 是一种对现实世界理解和抽象的方法
* 三大特征：
1.封装：隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性
2.继承：提高代码复用性；继承是多态的前提
3.多态：父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性
* 五大原则：
1.单一职责原则（SRP）：类的功能要单一
2.开放封闭原则（OCP）：一个模块对于拓展是开放的，对于修改是封闭的
3.里氏替换原则（LDP）：子类可以替换父类出现在父类能够出现的任何地方
4.依赖倒置原则（DIP）：高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象
5.接口分离原则（ISP）：设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好
* 优点：高内聚，低耦合，易维护，易复用，易扩展，
* 缺点：性能比面向对象要差

### 对象、类
* 什么是对象：对象就是类的实例-具体
* 什么是类：类就是拥有相等功能和相同的属性的对象的集合-抽象的

### 加速网站的最佳做法

[加速网站的最佳做法](https://developer.yahoo.com/performance/rules.html?from=from_parent_mindnote&guccounter=2&guce_referrer=aHR0cHM6Ly94aWFvbWkuZi5taW9mZmljZS5jbi8&guce_referrer_sig=AQAAAJ8CpS6MEUi_TFE9lp9laN81EwpAOFllMki3ZgllmMfMuR8JDx-VwxANer_DBbO0_8rM_BK23tfZ1Vo8omg56BCK5LBIx4HENX4mUsh1bV1s5wYhUnvca6g1vgVxwaukcFST8LJa1Sk47pCUOlM-XoizC5cZ06orFL9qKD_rsQWB)

1. 最小化HTTP请求
2. 使用CDN
3. 添加一个添加一个Expires或一个Cache-Control标头
4. 压缩代码 Gzip
5. 将样式放在顶部
6. 将脚本放在最下面
7. 避免css表达式
8. 将JavaScript和css设为外部
9. 减少DNS查找
10. 缩小JavaScript和css
11. 避免重定向
12. 删除重复脚本
13. 配置ETag
14. 使用ajax可缓存
15. 使用get发送ajax
16. 预加载组件
17. 减少DOM元素的数量
18. 跨域拆分组件
19. 减少iframe的数量
20. 不需要404，不需要发出HTTP请求并获得无用的响应
21. 减少cookie大小
22. 对组件使用无Cookie域
23. 最小化DOM访问
24. css链接弃用@import 选择`<link>`
25. 使用事件代理
26. 优化图片
27. 不要缩放HTML中的图像
28. 使favicon.ico小型且可缓存
29. 组件保持在25K以下
30. 将组件打包成多部分文档
31. 避免空图片src



# 大厂面试总结
## 字节跳动提前批前端实习生一面总结
* jsx怎样生成DOM并渲染到页面的，template怎样生成DOM并渲染到页面的
* 虚拟dom怎样生成真实dom的：patch函数
* vue中Object.defineProperty 为什么不能检测数组的改变
* 微任务，宏任务怎么理解，哪些是微任务，哪些是宏任务
* ES6语法转ES5语法问题，ES6clss转为ES5怎样写

## 小米面试总结
### 一面（2020-10-14）
* react传值问题：父子，字符，兄弟，都有哪些传值方法
* 说一下重绘和重排，怎样减少重绘和重排
* 手写判断日期的正则表达式
* 数组去重（复杂度尽可能低）
* 前端用户登录权鉴，JWT在前端中怎样使用的
* 面试时常：60min

### 二面（2020-10-20）
* 找出数组中各值有几个，返回一个对象
* vue data不使用函数的后果
* 说一下重绘和重排，怎样减少重绘和重排
* 用户输入url到页面展示有哪些流程
* 手写发布订阅模式
* 以后有什么打算
* 什么时候接触小米的，是个怎样的米粉
* 面试时常：40min

### 小米面试经验
* 首先开始介绍自己要向着自己的优势方向介绍，这样可以让面试官优先问你自己的优势处，这次的自我介绍还行，就是介绍项目的亮点给介绍倒了react hooks上，然后面试开始问react，问到了自己相对弱的地方，很难受，还有注重原理，大厂真的很爱问原理，注重基础方面

## 顺丰面试总结
### 一面（2020-11-14）
* 自我介绍
* css盒子模型
* cssBFC
* css选择器
* rem、em
* 判断数组的方法（isArray）
* forEach与map 的区别，是否修改原数组
* 如何使用for of遍历string（Object.entries()）
* promise的状态以及API介绍
* generator与async的区别
* 浏览器事件机制中，事件触发的三个阶段（捕获、目标、冒泡）
* 用户输入url到页面展示的流程介绍
* 三次握手
* 哪些情况会发生跨域（ajax、cookie、iframe）
* 协商缓存
* 怎样学习前端知识的
* useMemo与useCallback的区别
* 面试时常：45min

### 二面（2020-11-18）
* 自我介绍
* React生命周期介绍
* js中 0.1+0.2 为什么不等于0.3 怎样解决
* Math函数有哪些方法，random包含0和1吗
* css权重
* css样式冲突问题（vue中scoped的原理）
* git常用命令
* css画三角
* 写一个抽奖方法。有四等奖品，中奖概率如下 一等奖：10%，二等奖：15%，三等奖：25%，四等奖：50%
* 面试时常：45min




















