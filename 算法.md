# 算法
## 时间复杂度
* 定性描述该算法的运行时间 

## 空间复杂度
* 算法在运行过程中临时占用存储空间大小的量度

## 栈
* 一个后进先出的数据结构

### 什么情况下使用栈
* 例如：十进制转二进制，有效的括号，函数调用堆栈

## 队列
* 一个先进先出的数据结构

### 什么场景下使用队列
* 例如：js异步中的任务队列，计算最近请求次数

## 链表
* 多个元素组成的列表
* 元素存储不连续，用next指针连在一起

### 数组与链表
* 数组：增删非首尾元素时往往需要移动元素
* 链表：增删非首尾元素时不需要移动元素，只需要更改next的指向即可

## 集合（Set）
* 一种无序且唯一的数据结构，比如js中的set
* 常用操作：去重，判断元素是否在集合中，求交集

## 字典（Map）
* 与集合类似，字典是一种存储唯一值的数据结构，但它是以键值对的形式来存储
* 常用操作：键值对的增删改查

## 树
* 一种分层数据的抽象模型

```javascript
const tree = {
  val: 'a',
  children: [
    {
      val: 'b',
      children: [
        {
          val: 'd',
          children: []
        },
        {
          val: 'e',
          children: []
        }
      ]
    },
    {
      val: 'c',
      children: [
        {
          val: 'f',
          children: []
        },
        {
          val: 'g',
          children: []
        }
      ]
    }
  ]
}
```

### 深度优先遍历
* 尽可能深的搜索树的分支
* 口诀：访问根节点，对根节点的children挨个进行深度优先遍历（递归）

```javascript
// 深度优先遍历
const dfs = (root) => {
  console.log(root.val)
  // root.children.forEach(children => dfs(children))
  root.children.forEach(dfs)
}
dfs(tree)
```

### 广度优先遍历
* 先访问离根节点最近的节点
* 口诀：新建一个队列，把根节点入队，把队头出队并访问，把对头的children挨个入队，重复二、三步，直到队列为空

```javascript
// 广度优先遍历
const bfs = (root) => {
  const q = [root]
  while(q.length > 0) {
    const n = q.shift()
    console.log(n.val)
    n.children.forEach(child => {
      q.push(child)
    })
  }
}
bfs(tree)
```

### 二叉树
* 每个节点最多只能有两个子节点
* 先序遍历：根左右
* 中序遍历：左根右
* 后序遍历：左右根

```javascript
// 使用object构建二叉树
const bt = {
  val: 1,
  left: {
    val: 2,
    left: {
      val: 4,
      left: null,
      right: null
    },
    right: {
      val: 5,
      left: null,
      right: null
    }
  },
  right: {
    val: 3,
    left: {
      val: 6,
      left: null,
      right: null
    },
    right: {
      val: 7,
      left: null,
      right: null
    }
  }
}

// 先序遍历
  // 先序遍历（递归）
  const preorder = (root) => {
    if (!root) return
    console.log(root.val)
    preorder(root.left)
    preorder(root.right)
  }
  console.log('先序遍历')
  preorder(bt)

  // 先序遍历（非递归）
  const preorder = (root) => {
    if (!root) return
    // 获取当前的树
    const stack = [root]
    // 当树中还有值时进入循环
    while(stack.length) {
      // 抛出最后一个值
      let p = stack.pop()
      // console.log(p)
      // 抛出改对象的val
      console.log(p.val)
      // 若该对象右子树有值，添加值
      if (p.right) stack.push(p.right)
      // 若该对象左子树有值，添加值
      if (p.left) stack.push(p.left)
    }
  }
  console.log('先序遍历')
  preorder(bt)

// 中序遍历
  // 中序遍历（递归）
  const inorder = (root) => {
    if (!root) return
    inorder(root.left)
    console.log(root.val)
    inorder(root.right)
  }
  console.log('中序遍历')
  inorder(bt)
  
  // 中序遍历（非递归）
  const inorder = (root) => {
    if(!root) return
    // 创建一个空数组，用来存储当前数据
    const stack = []
    let p = root
    // 当stack或p有值则进入循环
    while(stack.length || p) {
      // 当p有值进入循环
      while(p) {
        // stack存储p值，整个循环先存储整个对象的根节点与left节点的值
        stack.push(p)
        // p等于p.left
        p = p.left
      }
      // 抛出数组最后一个
      const n = stack.pop()
      // 获取数组最后一个的val值
      console.log(n.val)
      // 获取抛出数组的right的值
      p = n.right
    }
  }
  console.log('中序遍历')
  inorder(bt)

// 后序遍历
  // 后序遍历（递归）
  const postorder = (root) => {
    if (!root) return
    postorder(root.left)
    postorder(root.right)
    console.log(root.val)
  }
  console.log('后序遍历')
  postorder(bt)

  // 后序遍历（非递归）
  const postorder = (root) => {
    if (!root) return
    // 获取当前的树
    const stack = [root]
    // 设置空数组 存储遍历数据
    const outPostorder = []
    // 当stack有值 进入循环
    while(stack.length) {
      // 抛出数组最后一个元素
      let p = stack.pop()
      // 将数组最后一个元素的val进行存储
      outPostorder.push(p.val)
      // 当抛出数组有left存储left
      if (p.left) stack.push(p.left)
      // 当抛出数组有right存储right
      if (p.right) stack.push(p.right)
    }
    //倒叙输出outPostorder的值
    while(outPostorder.length) {
      const n = outPostorder.pop()
      console.log(n)
    }
  }
  console.log('后序遍历')
  postorder(bt)
```

## 堆
* 堆是一种特殊的完全二叉树
* 所有的结点都大于等于（最大堆）或小于等于（最小堆）它的子结点
* js中通常使用数组表示堆
* 左侧子结点的位置是2 * index + 1
* 右侧子节点的位置是2 * index + 2
* 父节点的位置是（index - 1）/ 2
* 可以高效快速的找出最大值和最小值，时间复杂度O(1)
* 可以找出第K个最大元素：构建一个最小堆，并将元素以此插入堆中。当堆的容量超过K，就删除堆顶。插入结束后，堆顶就是第K个最大元素

```javascript
/**
 * 堆的插入操作：
 * 1、将输出值插入数组最后(push)
 * 2、将插入值进行向上转换，通过插入值的下标也就是当前数组的长度-1获取到父结点的下标值（（index - 1）/ 2），判断子节点月父节点大小，当父节点大于子节点时，进行交换操作.
 * 3、交换完成后，当前子节点就是之前父节点，有可能比现在的父节点还小，那么继续第二步操作，知到当前结点小标为0时，不进行操作
 */

 /**
  * 堆的删除操作:
  * 1、移除数组的最后以为并将最后一位赋值给首位(pop)
  * 2、进行下移操作，如果大于左子结点(2 * index + 1)或右边子结点(2 * index + 2)则进行交换操作，交换完后可能还大与左/右子结点，则继续进行交换。
  */
  
// 最小堆
class MinHeap {
  constructor () {
    this.heap = []
  }
  
  // 子节点与父节点交换位置
  shiftUp(index) {
    // 如果到达顶部，不进行操作
    if (index == 0) {return;}
    // 获取父节点的下标
    const ParentIndex = this.getParentIndex(index)
    if (this.heap[ParentIndex] > this.heap[index]) {
      // 父子结点交换
      this.swap(ParentIndex, index)
      // 子节点可能会继续网上移动
      this.shiftUp(ParentIndex)
    }
  }
  // 获取父节点的下标
  getParentIndex(index) {
    // return Math.floor((index - 1) / 2)
    return (index - 1) >> 1;
  }
  // 交换操作
  swap(i1, i2) {
    const temp = this.heap[i1]
    this.heap[i1] = this.heap[i2]
    this.heap[i2] = temp
  }

  // 进行下移操作
  shiftDown(index) {
    const LeftIndex = this.getLeftIndex(index)
    const RightIndex = this.getRightIndex(index)
    // console.log(index, LeftIndex, RightIndex)
    if (this.heap[LeftIndex] < this.heap[index]) {
      this.swap(LeftIndex, index)
      this.shiftDown(LeftIndex)
    }
    if (this.heap[RightIndex] < this.heap[index]) {
      this.swap(RightIndex, index)
      this.shiftDown(RightIndex)
    }
  }
  // 获取左子结点下标
  getLeftIndex(index) {
    return 2 * index + 1
  }
  // 获取右子结点下标
  getRightIndex(index) {
    return 2 * index + 2
  }
  // 插入操作
  insert(value) {
    this.heap.push(value)
    this.shiftUp(this.heap.length - 1)
    // console.log(this.heap)
  }
  // 删除头顶结点操作
  pop() {
    // 移除数组最后一个值并赋值给第一个
    this.heap[0] = this.heap.pop()
    this.shiftDown(0)
    console.log(this.heap)
  }
  // 获取堆顶
  peek() {
    return this.heap[0]
  }
  // 获取堆的大小
  size() {
    return this.heap.length
  }
}
```


## 图
* 图是网络结构的抽象模型，是一组由边连接的节点，可以表示任何二元关系
* 可以实用Object，Array构建图
* 图的表示法：邻接矩阵，邻接表，关联矩阵

```javascript
// 构建图
const graph = {
  0: [1, 2],
  1: [2],
  2: [0, 3],
  3: [3]
}
```

### 深度优先遍历
* 尽可能深的搜索图分支
* 口诀：访问根节点，对根节点的没访问过的相邻节点挨个进行深度优先遍历

```javascript
// 深度遍历
const visited = new Set()
const dfs = (n) => {
  console.log(n)
  visited.add(n)
  graph[n].forEach(item => {
    if (!visited.has(item)) {
      dfs(item)
    }
  })
}
dfs(2) // 2 0 1 3
```

### 广度优先遍历
* 先访问离根节点最近的节点
* 口诀：新建一个队列，把根节点入队，把队头出队并访问，把队头的没访问过的相邻节点入队，重复二、三步，直到列队为空

```javascript
// 广度遍历
const visited = new Set()
const bfs = (n) => {
  visited.add(n)
  const q = [n]
  while(q.length) {
    const s = q.shift()
    console.log(s)
    graph[s].forEach(item => {
      if(!visited.has(item)) {
        q.push(item)
        visited.add(item)
      }
    })
  } 
}

bfs(2) // 2 0 3 1
```










